<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>One MTC</title>
<script src="auth.js"></script>
  <script>
  requireLogin();
 </script>
 <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>

  <style>
    body {  
  font-family: sans-serif; 
  margin: 20px; 
  background: #fafafa; 
}

/* Controls */
.controls {
  display: flex; gap: 10px; align-items: center; margin-bottom: 10px;
  flex-wrap: wrap;
}
.controls input {
  flex: 1; min-width: 220px; padding: 6px; font-size: 14px;
  border-radius: 12px; border: 1px solid #ccc;
}
.btn {
  padding: 6px 12px; font-size: 14px; border: none; color: #fff; 
  border-radius: 12px; cursor: pointer;
}
#woSearchBtn { background: linear-gradient(to bottom, var(--bg-top), var(--bg-bottom)); }
#woSearchBtn:hover { background: #005fa3; }
#startScanBtn { background: #28a745; }
#startScanBtn.scanning { background: #218838; box-shadow: 0 0 0 2px rgba(40,167,69,.2) inset; }
#stopScanBtn { background: #dc3545; border-radius: 12px; }
#stopScanBtn:hover { background: #c82333; }

#counter { margin-bottom: 15px; font-weight: bold; }
#counter .highlight { color: #28a745; }

/* Layout wrapper */
.layout {
  margin-top: 110px;
  display: flex;
  gap: 20px;
  align-items: flex-start;
  flex-wrap: wrap;
}

/* Left column (phase only now) */
.left-column {
  flex: 0 0 400px;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

/* Main table */
#scrollArea {
  flex: 1;
  min-width: 450px;
  height: 650px;
  overflow-y: auto;
  border: 1px solid #aaa;
  background: #fff;
  border-radius: 12px;
}

/* Phase totals */
#phaseTotalsTable {
  border-collapse: collapse;
  width: 100%;
  font-size: 14px;
  background: #fff;
  border-radius: 12px;
  overflow: hidden;
}
#phaseTotalsTable th, #phaseTotalsTable td {
  border: 1px solid #ddd;
  padding: 6px;
}
#phaseTotalsTable th {
  background: #f5f5f5;
}

/* Mobile responsive */
@media (max-width: 900px) {
  .layout {
    flex-direction: column;
  }
  .left-column, #scrollArea {
    flex: 1 1 100%;
    max-width: 100%;
  }
}

/* Main scrollable table */
.clusterize-scroll {
  flex: 1; height: 500px; overflow-y: auto; border: 1px solid #aaa; 
  background: #fff; border-radius: 12px;
}
table { width: 100%; border-collapse: collapse; table-layout: fixed; }
th, td { 
  padding: 6px; border: 1px solid #ddd; font-size: 14px; text-align: left; 
  overflow: hidden; border-radius: 6px;
}
thead th { background: #f5f5f5; position: sticky; top: 0; z-index: 2; }
thead input { width: 95%; padding: 4px; font-size: 12px; box-sizing: border-box; border-radius: 8px; }

/* Responsive */
@media (max-width: 900px) {
  .layout { flex-direction: column; }
  #phaseTotalsContainer { max-width: 100%; width: 100%; }
}

/* Loading overlay */
#loadingOverlay {
  position: fixed; inset: 0; background: rgba(255,255,255,0.8);
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  z-index: 9999; font-size: 18px; color: #333; opacity: 1; transition: opacity .5s ease;
  border-radius: 0;
}
#loadingOverlay.hidden { opacity: 0; pointer-events: none; }
#loadingOverlay .spinner {
  border: 4px solid #ccc; border-top: 4px solid #0078d7;
  border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 10px;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* Skill filters */
.skill-filters { margin: 10px 0 15px; display: flex; flex-wrap: wrap; gap: 8px; }
.skill-filters button {
  padding: 6px 12px; font-size: 14px; background: #b4b3b3; color: #fff; 
  border: none; border-radius: 12px; cursor: pointer; transition: background .2s;
}
.skill-filters button:hover { background: #333; }
.skill-filters button.active { background: linear-gradient(to bottom, var(--bg-top), var(--bg-bottom));}

/* Scan Modal */
#scanModal {
  display: none; position: fixed; inset: 0; background: rgba(0,0,0,.6);
  align-items: center; justify-content: center; z-index: 10000;
}
#scanModal .modal-content {
  background: #fff; padding: 16px; border-radius: 8px; width: 420px; max-width: calc(100% - 24px);
  max-height: 80vh; overflow: auto; box-shadow: 0 10px 30px rgba(0,0,0,.35);
}
#scanModal h3 { margin: 0 0 8px; }
#scannedList { list-style: none; padding: 0; margin: 8px 0; }
#scannedList li {
  display: flex; align-items: center; justify-content: space-between;
  padding: 6px 8px; border: 1px solid #eee; border-radius: 6px; margin-bottom: 6px; background: #f9f9f9;
  font-variant-numeric: tabular-nums;
}
.pill { font-size: 12px; padding: 2px 6px; background: #eee; border-radius: 10px; }
.li-actions button { border: none; background: #ef5350; color: #fff; padding: 4px 8px; border-radius: 4px; cursor: pointer; }
.li-actions button:hover { background: #d32f2f; }
.modal-actions { display: flex; gap: 8px; margin-top: 10px; justify-content: flex-end; }
#submitScanBtn { background: #28a745; }
#clearScanBtn { background: #6c757d; }
#closeScanBtn { background: #dc3545; }

/* Hidden barcode input */
#barcodeInput { position: absolute; left: -9999px; top: -9999px; }

/* Toast Notifications */
#toastContainer {
  position: fixed;
  top: 20px;
  right: 20px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  z-index: 11000;
}
.toast {
  background: #333;
  color: #fff;
  padding: 10px 16px;
  border-radius: 6px;
  font-size: 14px;
  opacity: 0;
  transform: translateX(100%);
  transition: all 0.4s ease;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}
.toast.show {
  opacity: 1;
  transform: translateX(0);
}
.toast.success { background: #28a745; }
.toast.error   { background: #dc3545; }
.toast.info    { background: #0078d7; }

:root {
  --bg-top: #0f172a;
  --bg-bottom: #1e3a8a;
  --card: rgba(255,255,255,0.08);
  --muted: #9ca3af;
  --accent: #ffcc00; /* Lufthansa yellow */
  --error: #ef4444;
  --radius: 14px;
}

.plan-header {
  top: 0;
  z-index: 100;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: linear-gradient(to bottom, var(--bg-top), var(--bg-bottom));
  padding: 8px 12px;
  border-radius: var(--radius);
  margin-bottom: 20px;
}
.plan-heading {
  font-size: 18px;
  font-weight: 700;
  color: #d0d0d0;
}
.logout-btn {
  background: linear-gradient(to bottom, var(--bg-top), var(--bg-bottom));
  color: rgb(244, 236, 236);
  padding: 8px 16px;
  border:#f4f4f4;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
}
.logout-btn:hover { background: var(--accent); }
.liveUpdate {
  font-size: 0.9rem;
  color: #cbd5e1;
  margin-left: auto;
  padding-right: 10px;
}

.header1 {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  z-index: 9999;
  background: #fafafa;
  box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}
.skill-open {
  color: #dc3545;
  font-weight: bold;
}

.skill-closed {
  color: #28a745;
  font-weight: bold;
}
.skill-highlight {
 
  padding: 2px 4px;
  border-radius: 4px;
}
.skill-faded {
  opacity: 0.6;
  font-weight: lighter;
}

  </style>
</head>
<body>
<div Class="header1">
    <div class="plan-header">
    <div class="plan-heading" id="dynamicHeader">Loading‚Ä¶</div>
    <span id="lastUpdate" class="liveUpdate" ></span>
    <button onclick="logout()" class="logout-btn">Logout</button>
    </div>

    <div class="controls">
    <input type="text" id="woInput" placeholder="Enter Workorder" />
    <button class="btn" id="woSearchBtn">Search</button>
    <button class="btn" id="startScanBtn" title="Activate barcode scanner">Scan Here!!!</button>
    <button class="btn" id="stopScanBtn" title="Stop scanner" style="display:none;">Stop Scan</button>
    <!-- Hidden input to capture scanner keystrokes -->
    <input type="text" id="barcodeInput" autocomplete="off" />
     </div>

    <div class="skill-filters">
    <button data-skill="CLEAR" class="active">ALL SKILL</button>
    <button data-skill="GEN">GEN</button>
    <button data-skill="AVI">AVI</button>
    <button data-skill="CRG/ENG">CRG/ENG</button>
    <button data-skill="CAB">CAB</button>
    <button data-skill="LDG/FLC">LDG/FLC</button>
    <button data-skill="STR">STR</button>
    <button data-skill="SHOP">SHOP</button>
    
  </div>

  <div id="counter">Waiting for input...</div>
</div>
  <div class="layout">
  <!-- Phase totals -->
  <div class="layout">
  <!-- Left column: Phase + Skill -->
  <div class="left-column">
    <!-- Phase totals -->
    <div id="phaseTotalsContainer">
      <table id="phaseTotalsTable">
        <thead>
          <tr>
            <th>Phase</th>
            <th style="text-align:right;">Open Tasks</th>
            <th style="text-align:right;">Closed Tasks</th>
            <th style="text-align:right;">% Closed</th>
          </tr>
        </thead>
        <tbody id="phaseTotalsBody">
          <tr><td colspan="4" style="text-align:center;">No data</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- Main table -->
  <div id="scrollArea" class="clusterize-scroll">
    <table>
<thead>
  <tr>
    <th style="width:15%;">Reference</th>
    <th style="width:25%;">Description</th>
    <th style="width:10%;">Seq.No</th>

  </tr>
  <tr>
    <th><input type="text" class="filter" data-field="reference_task_card" placeholder="Search Reference" /></th>
    <th><input type="text" class="filter" data-field="task_card_description" placeholder="Search Description" /></th>
    <th><input type="text" class="filter" data-field="seq" placeholder="Search Seq" /></th>
                  <th>
 <select class="filter" data-field="mtcStatus" aria-label="Filter by MTC Status" title="Filter by MTC Status">
  <option value="">All</option>
  <option value="Closed">Closed</option>
  <option value="Open">Open</option>
</select>
      </th>
  </tr>
</thead>

      <tbody id="contentArea" class="clusterize-content">
        <tr class="clusterize-no-data"><td colspan="7">No data yet</td></tr>
      </tbody>
    </table>
  </div>
</div>

  <!-- Scan Modal -->
  <div id="scanModal" role="dialog" aria-modal="true" aria-labelledby="scanModalTitle">
    <div class="modal-content">
      <h3 id="scanModalTitle">Scanned Sequences</h3>
      <div style="font-size:12px;color:#555;">WO: <span id="activeWO" class="pill">‚Äî</span> ‚Ä¢ Count: <span id="scanCount" class="pill">0</span></div>
      <ul id="scannedList"></ul>
                    <!-- Manual input for seq number -->
        <div id="manualInputContainer" style="margin-top:10px;">
        <input type="number" id="manualSeqInput" placeholder="Enter Seq Number manually">
        <button id="manualAddBtn">Add</button>
        </div>
      <div class="modal-actions">
        <button class="btn" id="submitScanBtn" title="Update matched tasks to CLOSED">Submit</button>
        <button class="btn" id="clearScanBtn" title="Clear list">Clear</button>
        <button class="btn" id="closeScanBtn" title="Close modal">Close</button>
      </div>
    </div>
  </div>

  <!-- Loading -->
  <div id="loadingOverlay">
    <div class="spinner"></div>
    <div>Loading, please wait...</div>
  </div>
<!-- Toast Notifications -->
<div id="toastContainer"></div>

  <script src="https://cdn.jsdelivr.net/npm/clusterize.js@0.18.1/clusterize.min.js"></script>
  <script type="module">
          const SESSION_KEY = "demo_session";
    const savedSession = JSON.parse(localStorage.getItem(SESSION_KEY) || sessionStorage.getItem(SESSION_KEY));
     if (!savedSession) {
      location.href = "index.html"; // not logged in
    } else {
        // Role-based access check
      const page = location.pathname.split("/").pop(); // current file name
      if (savedSession.page !== page) {
        location.href = "index.html"; // redirect if wrong user for this page
      }
      }
        
    
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import {
      getFirestore, collection, onSnapshot, query, where,
      doc, updateDoc, getDocs
    } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

    /* =======================
       Firebase Init
    ======================== */
    const firebaseConfig = {
      apiKey: "AIzaSyDCpHhUL8x4rs-fom1xyaNdWm5prSGf57U",
      authDomain: "onemtc-2222c.firebaseapp.com",
      projectId: "onemtc-2222c",
      storageBucket: "onemtc-2222c.firebasestorage.app",
      messagingSenderId: "447271556426",
      appId: "1:447271556426:web:562ba4d72e40b754599db3"
    };
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    signInAnonymously(auth).catch(console.error);

    /* =======================
       UI refs
    ======================== */
    const counterEl = document.getElementById("counter");
const woInput = document.getElementById("woInput");
const woSearchBtn = document.getElementById("woSearchBtn");
const overlay = document.getElementById("loadingOverlay");
const startScanBtn = document.getElementById("startScanBtn");
const stopScanBtn = document.getElementById("stopScanBtn");
const barcodeInput = document.getElementById("barcodeInput");
const scanModal = document.getElementById("scanModal");
const scannedList = document.getElementById("scannedList");
const submitScanBtn = document.getElementById("submitScanBtn");
const clearScanBtn = document.getElementById("clearScanBtn");
const closeScanBtn = document.getElementById("closeScanBtn");
const activeWOEl = document.getElementById("activeWO");
const scanCountEl = document.getElementById("scanCount");
const lastUpdateEl = document.getElementById('lastUpdate');

const clusterize = new Clusterize({ scrollId: 'scrollArea', contentId: 'contentArea', rows: [] });

/* =======================
   State
======================== */
let unsubscribe = null;
let allDocs = [];
let activeSkill = "CLEAR";
let scanningActive = false;
let scannedSeqs = [];
let currentWO = null;
let seqFilterValues = [];

const phaseOrder = ["PH", "P0", "P1", "P2", "P3", "P4", "P5", "P6"];

function seqKey(item) {
  if (item == null || item.seq == null) return Number.POSITIVE_INFINITY;
  const s = String(item.seq).trim();
  const parts = s.split('-');
  const last = parts[parts.length - 1];
  const n = Number(last);
  if (!Number.isNaN(n)) return n;
  const whole = Number(s);
  return Number.isNaN(whole) ? s : whole;
}

function getClosedPercentage(docs) {
  if (!docs.length) return 0;
  const closedCount = docs.filter(d => {
    const st = (d.status || "").toLowerCase();
    return st === "closed" || st === "completed";
  }).length;
  return ((closedCount / docs.length) * 100).toFixed(1);
}

/* =======================
   Helpers
======================== */
function calculateDayProgress(startDate, endDate) {
  if (!startDate || !endDate) return "";
  const start = new Date(startDate);
  const end = new Date(endDate);
  const today = new Date();
  const totalDays = Math.ceil((end - start) / (1000 * 60 * 60 * 24));
  const currentDay = Math.min(
    Math.max(Math.ceil((today - start) / (1000 * 60 * 60 * 24)) + 1, 1),
    totalDays
  );
  return `Day ${currentDay} of ${totalDays}`;
}

const showLoading = () => { overlay.style.display = "flex"; };
const hideLoading = () => { overlay.style.display = "none"; };




function getAvailablePhases(docs) {
  const phaseSet = new Set();
  docs.forEach(d => {
    if (d.phase) phaseSet.add(d.phase);
  });
  return Array.from(phaseSet).sort((a, b) => {
    // sort P1, P2, P3 numerically
    const na = parseInt(a.replace("P", "")) || 0;
    const nb = parseInt(b.replace("P", "")) || 0;
    return na - nb;
  });
}

function renderTableHeader(phases) {
  const thead = document.querySelector("#scrollArea thead");

  // --- 1) capture existing filter values + active input state ---
  const existingFilters = {};
  if (thead) {
    thead.querySelectorAll(".filter").forEach(inp => {
      const f = inp.dataset.field;
      if (f) existingFilters[f] = inp.value;
    });
  }

  // capture focused field + selection so we can restore after re-render
  const activeEl = document.activeElement;
  const activeInThead = activeEl && thead && thead.contains(activeEl);
  const activeField = activeInThead ? activeEl.dataset?.field : null;
  const selStart = activeInThead && typeof activeEl.selectionStart === "number" ? activeEl.selectionStart : null;
  const selEnd = activeInThead && typeof activeEl.selectionEnd === "number" ? activeEl.selectionEnd : null;

  // --- 2) build new header HTML ---
  const headerRow = `
    <tr>
      <th style="width:15%;">Reference</th>
      <th style="width:25%;">Description</th>
      <th style="width:10%;">Seq.No</th>
      <th style="width:10%;">MTCstatus</th>
      ${phases.map(p => `<th style="width:8%;"></th>`).join("")}
    </tr>
  `;

  const filterRow = `
    <tr>
      <th><input type="text" class="filter" data-field="reference_task_card" placeholder="Search Reference" /></th>
      <th><input type="text" class="filter" data-field="task_card_description" placeholder="Search Description" /></th>
      <th><input type="text" class="filter" data-field="seq" placeholder="Search Seq" /></th>
              <th>
 <select class="filter" data-field="mtcStatus" aria-label="Filter by MTC Status" title="Filter by MTC Status">
  <option value="">All</option>
  <option value="Closed">Closed</option>
  <option value="Open">Open</option>
</select>
      </th>
      ${phases.map(p => `<th style="width:8%;">${p}</th>`).join("")}
    </tr>
  `;

  // replace thead content
  thead.innerHTML = headerRow + filterRow;

  // --- 3) restore values & reattach listeners ---
  thead.querySelectorAll(".filter").forEach(inp => {
    const f = inp.dataset.field;
    if (existingFilters[f] !== undefined) inp.value = existingFilters[f];

    // attach main input handler
    inp.addEventListener("input", applyFilters);

    // special handling for seq input (Enter = push to seqFilterValues)
    if (f === "seq") {
      inp.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          const val = inp.value.trim();
          if (val !== "" && !seqFilterValues.includes(val)) {
            seqFilterValues.push(val);
          }
          inp.value = "";
          applyFilters();
        }
      });
    }
  });

  // --- 4) restore focus + caret if user was typing ---
  if (activeField) {
    const newActive = thead.querySelector(`.filter[data-field="${activeField}"]`);
    if (newActive) {
      newActive.focus();
      if (selStart !== null && typeof newActive.setSelectionRange === "function") {
        try { newActive.setSelectionRange(selStart, selEnd); } catch (err) { /* ignore */ }
      }
    }
  }
}

function buildSeqStatusMap(docs) {
  const seqStatus = {};
  docs.forEach(d => {
    const seq = String(d.seq || "");
    if (!seq) return;

    if (!seqStatus[seq]) {
      seqStatus[seq] = { total: 0, closed: 0 };
    }
    seqStatus[seq].total++;
    const st = (d.status || "").toLowerCase();
    if (st === "closed" || st === "completed") {
      seqStatus[seq].closed++;
    }
  });

  const result = {};
  Object.keys(seqStatus).forEach(seq => {
    result[seq] =
      seqStatus[seq].total === seqStatus[seq].closed ? "Closed" : "Open";
  });
  return result;
}

function renderRows(docs) {
  const phases = getAvailablePhases(docs);
  renderTableHeader(phases);

  const grouped = {};
  docs.forEach(d => {
    const ref = d.reference_task_card || "Unknown";
    if (!grouped[ref]) {
      grouped[ref] = {
        ref,
        description: d.task_card_description ?? "",
        seq: d.seq ?? "",
        phases: {},
        tasks: []
      };
    }
    if (!grouped[ref].phases[d.phase]) {
      grouped[ref].phases[d.phase] = [];
    }
    grouped[ref].phases[d.phase].push(d.skill || "");
    grouped[ref].tasks.push(d);
  });

  // ‚úÖ Precompute seq ‚Üí status map (O(N))
  const seqStatusMap = buildSeqStatusMap(docs);

  const rows = Object.values(grouped).map(item => {
    // ‚úÖ Fast O(1) lookup instead of filtering all docs
    let mtcStatus = "Open";
    if (item.seq && seqStatusMap[item.seq]) {
      mtcStatus = seqStatusMap[item.seq];
    }

    const phaseCells = phases
      .map(p => {
        const skills = item.phases[p]
          ? item.phases[p]
              .map(s => {
                const doc = docs.find(
                  d =>
                    d.reference_task_card === item.ref &&
                    d.phase === p &&
                    d.skill === s
                );
                const status = (doc?.status || "").toLowerCase();
                const baseClass =
                  status === "closed" || status === "completed"
                    ? "skill-closed"
                    : "skill-open";

                let extraClass = "";
                if (activeSkill !== "CLEAR") {
                  if (skillGroups[activeSkill]?.includes(s)) {
                    extraClass = " skill-highlight";
                  } else {
                    extraClass = " skill-faded";
                  }
                }

                return `<span class="skill ${s.replace(
                  /\W/g,
                  "-"
                )} ${baseClass}${extraClass}">${s}</span>`;
              })
              .join("<br>")
          : "";

        return `<td style="text-align:center; white-space:pre-line;">${skills}</td>`;
      })
      .join("");

    return `
      <tr>
        <td>${item.ref}</td>
        <td>${item.description}</td>
        <td>${item.seq}</td>
        <td style="text-align:center; font-weight:bold; color:${
          mtcStatus === "Closed" ? "#28a745" : "#dc3545"
        };">
          ${mtcStatus}
        </td>
        ${phaseCells}
      </tr>
    `;
  });

  clusterize.update(
    rows.length
      ? rows
      : [
          `<tr class="clusterize-no-data"><td colspan="${
            4 + phases.length
          }">No data</td></tr>`
        ]
  );
}


function renderPhaseTotals(docs) {
  const container = document.getElementById("phaseTotalsContainer");
  const body = document.getElementById("phaseTotalsBody");

  body.innerHTML = "";

  if (!docs.length) {
    body.innerHTML = `<tr><td colspan="4" style="text-align:center;">No tasks by phase.</td></tr>`;
    return;
  }

  // üÜï Update heading dynamically
  const skillLabel = activeSkill === "CLEAR" ? "All Skills" : activeSkill;
  container.querySelector("thead tr th:first-child").textContent = `Phase Totals (${skillLabel})`;

  // ‚úÖ Single pass aggregation
  const totals = {};
  docs.forEach(d => {
    const phase = d.phase || "No Phase";
    if (!totals[phase]) totals[phase] = { total: 0, open: 0, closed: 0 };
    totals[phase].total++;
    const st = (d.status || "").toLowerCase();
    if (st === "open") totals[phase].open++;
    if (st === "closed" || st === "completed") totals[phase].closed++;
  });

  // ‚úÖ Order phases
  const orderedPhases = [
    ...phaseOrder.filter(p => totals[p]),
    ...Object.keys(totals).filter(p => !phaseOrder.includes(p))
  ];

  orderedPhases.forEach(phase => {
    const { total, open, closed } = totals[phase];
    const pct = total ? ((closed / total) * 100).toFixed(1) : "0.0";
    const pctStyle = pct === "100.0" ? "color:#28a745; font-weight:bold;" : "color:inherit;";

    body.insertAdjacentHTML("beforeend", `
      <tr>
        <td>${phase}</td>
        <td style="text-align:right;">${open}</td>
        <td style="text-align:right;">${closed}</td>
        <td style="text-align:right; ${pctStyle}">${pct}%</td>
      </tr>
    `);
  });
}


const skillGroups = {
  "CLEAR": [],
  "AVI": ["AVI"],
  "CRG/ENG": ["CRG", "ENG-E", "ENG-F"],
  "CAB": ["CAB"],
  "LDG/FLC": ["LDG", "FLC-W", "FLC-T"],
  "STR": ["STR"],
  "GEN":["GEN"],
  "SHOP": []
};

function getSkillFilteredDocs() {
  if (activeSkill === "CLEAR") return allDocs;

  if (activeSkill === "SHOP") {
    const excluded = new Set(Object.values(skillGroups).flat().filter(Boolean));
    return allDocs.filter(d => !excluded.has(d.skill));
  }

  const skills = skillGroups[activeSkill] || [];
  // instead of filtering docs directly, just mark eligible references
  const eligibleRefs = new Set(allDocs
    .filter(d => skills.includes(d.skill))
    .map(d => d.reference_task_card)
  );

  return allDocs.filter(d => eligibleRefs.has(d.reference_task_card));
}
// ‚úÖ Use this for stats (phase totals, counter, % closed)
function getSkillDocsForStats() {
  if (activeSkill === "CLEAR") return allDocs;

  if (activeSkill === "SHOP") {
    const excluded = new Set(Object.values(skillGroups).flat().filter(Boolean));
    return allDocs.filter(d => !excluded.has(d.skill));
  }

  const skills = skillGroups[activeSkill] || [];
  return allDocs.filter(d => skills.includes(d.skill));
}

// ‚úÖ Use this for table display (still shows all skills for a ref)
function getSkillDocsForDisplay() {
  if (activeSkill === "CLEAR") return allDocs;

  if (activeSkill === "SHOP") {
    const excluded = new Set(Object.values(skillGroups).flat().filter(Boolean));
    return allDocs.filter(d => !excluded.has(d.skill));
  }

  const skills = skillGroups[activeSkill] || [];
  const eligibleRefs = new Set(allDocs
    .filter(d => skills.includes(d.skill))
    .map(d => d.reference_task_card)
  );

  return allDocs.filter(d => eligibleRefs.has(d.reference_task_card));
}


function applyFilters() {
  const filters = {};
  document.querySelectorAll(".filter").forEach(input => {
    const v = input.value.trim();
    if (v !== "" && input.dataset.field !== "seq") {
      filters[input.dataset.field] = v.toLowerCase();
    }
  });

  // ‚úÖ Step 1: get data for display & stats separately
  let displayDocs = getSkillDocsForDisplay();
  let statsDocs = getSkillDocsForStats();

  // ‚úÖ Step 2: apply text filters to both sets
  const filterFn = d =>
    Object.keys(filters).every(field =>
      String(d[field] ?? "").toLowerCase().includes(filters[field])
    );

  displayDocs = displayDocs.filter(filterFn);
  statsDocs = statsDocs.filter(filterFn);

  // ‚úÖ Step 3: seq filters
  if (scannedSeqs.length > 0) {
    displayDocs = displayDocs.filter(d => scannedSeqs.includes(Number(d.seq)));
    statsDocs = statsDocs.filter(d => scannedSeqs.includes(Number(d.seq)));
  } else if (seqFilterValues.length > 0) {
    displayDocs = displayDocs.filter(d => seqFilterValues.includes(String(d.seq)));
    statsDocs = statsDocs.filter(d => seqFilterValues.includes(String(d.seq)));
  }

  // ‚úÖ Step 4: render table from display docs
  renderRows(displayDocs);

  // ‚úÖ Step 5: compute stats from stats docs only
  const pctClosed = getClosedPercentage(statsDocs);
  counterEl.innerHTML = `Showing ${statsDocs.length} of ${allDocs.length} tasks ‚Ä¢ <span class="highlight">${pctClosed}% Closed</span>`;
  renderPhaseTotals(statsDocs);
}





const seqInput = document.querySelector('.filter[data-field="seq"]');
seqInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    const val = seqInput.value.trim();
    if (val !== "" && !seqFilterValues.includes(val)) {
      seqFilterValues.push(val);
    }
    seqInput.value = "";
    applyFilters();
  }
});

// Skill buttons
document.querySelectorAll(".skill-filters button").forEach(btn => {
  btn.addEventListener("click", () => {
    document.querySelectorAll(".skill-filters button").forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    activeSkill = btn.dataset.skill;

    if (activeSkill === "CLEAR") {
      scannedSeqs = [];
      seqFilterValues = [];
      document.querySelectorAll(".filter").forEach(input => input.value = "");
    }

    applyFilters();
  });
});

// Text filters
document.querySelectorAll(".filter").forEach(input => input.addEventListener("input", applyFilters));

/* =======================
   Firestore Query by WO
======================== */
function searchWorkorder(wo) {
  if (!wo) return;
  showLoading();
  counterEl.textContent = "Loading tasks...";
  localStorage.setItem("lastWorkorder", wo);
  if (unsubscribe) { unsubscribe(); unsubscribe = null; }

  currentWO = isNaN(wo) ? wo : Number(wo);
  activeWOEl.textContent = String(currentWO);

  const qWO = query(collection(db, "tasks"), where("wo", "==", currentWO));
  unsubscribe = onSnapshot(qWO, (snapshot) => {
    allDocs = snapshot.docs.map(docSnap => ({ id: docSnap.id, ...docSnap.data() }));
    const pctClosed = getClosedPercentage(allDocs);
    counterEl.innerHTML = `Total Tasks: ${snapshot.size} ‚Ä¢ <span class="highlight">${pctClosed}% Closed</span>`;
    if (allDocs.length > 0) {
      const ac = allDocs[0].ac || "Unknown AC";
      const schedStart = allDocs[0].sched_start_date;
      const schedEnd = allDocs[0].sched_end_date;
      const dayProgress = calculateDayProgress(schedStart, schedEnd);
      document.getElementById("dynamicHeader").textContent =
        `MTC Status for ${ac}    ${dayProgress}`;
    }
    lastUpdateEl.textContent = "Live ‚Ä¢ " + new Date().toLocaleString();
    document.querySelectorAll(".skill-filters button").forEach(b => b.classList.remove("active"));
    document.querySelector('.skill-filters button[data-skill="CLEAR"]').classList.add("active");
    activeSkill = "CLEAR";
    renderRows(allDocs);
    renderPhaseTotals(allDocs);
    hideLoading();
  }, (err) => {
    console.error(err);
    hideLoading();
    alert("Error loading tasks.");
  });
}

woSearchBtn.addEventListener("click", () => {
  const wo = woInput.value.trim();
  if (wo) searchWorkorder(wo);
});

const lastWO = localStorage.getItem("lastWorkorder");
if (lastWO) { woInput.value = lastWO; searchWorkorder(lastWO); }

/* =======================
   Scan Modal + Scanner
======================== */
function openModal() { scanModal.style.display = "flex"; }
function closeModal() { scanModal.style.display = "none"; }
const manualSeqInput = document.getElementById("manualSeqInput");
const manualAddBtn = document.getElementById("manualAddBtn");

manualAddBtn.addEventListener("click", () => {
  const value = manualSeqInput.value.trim();
  if (value !== "") {
    handleScannedValue(value);
    manualSeqInput.value = "";
  }
});
manualSeqInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    manualAddBtn.click();
  }
});

function setScanning(active) {
  scanningActive = active;
  startScanBtn.classList.toggle("scanning", active);
  startScanBtn.disabled = active;
  stopScanBtn.style.display = active ? "inline-block" : "none";
  if (active) {
    barcodeInput.value = "";
    barcodeInput.focus();
  } else {
    barcodeInput.blur();
  }
}

startScanBtn.addEventListener("click", () => {
  if (!currentWO && !woInput.value.trim()) {
    alert("Enter a Workorder first, then click Search.");
    return;
  }
  if (!currentWO && woInput.value.trim()) {
    searchWorkorder(woInput.value.trim());
  }
  setScanning(true);
  openModal();
});

stopScanBtn.addEventListener("click", () => setScanning(false));

barcodeInput.addEventListener("keydown", (e) => {
  if (!scanningActive) return;
  if (e.key === "Enter") {
    const val = barcodeInput.value.trim();
    barcodeInput.value = "";
    if (val !== "") handleScannedValue(val);
  }
});

function renderScannedList() {
  scannedList.innerHTML = "";
  if (!scannedSeqs.length) {
    scannedList.innerHTML = `<li style="justify-content:center;color:#777;">No scans yet</li>`;
  } else {
    scannedSeqs.forEach(seq => {
      const li = document.createElement("li");
      li.innerHTML = `<span>${seq}</span>
        <span class="li-actions">
          <button type="button" data-remove="${seq}">Remove</button>
        </span>`;
      scannedList.appendChild(li);
    });
  }
  scanCountEl.textContent = String(scannedSeqs.length);
}

scannedList.addEventListener("click", (e) => {
  const btn = e.target.closest("button[data-remove]");
  if (!btn) return;
  const seq = Number(btn.getAttribute("data-remove"));
  scannedSeqs = scannedSeqs.filter(x => x !== seq);
  renderScannedList();
});

function handleScannedValue(raw) {
  const num = Number(raw);
  if (Number.isNaN(num)) {
    alert(`Invalid sequence (not a number): "${raw}"`);
    return;
  }
  if (!scannedSeqs.includes(num)) {
    scannedSeqs.push(num);
    renderScannedList();
    applyFilters();
  }
  if (scanModal.style.display !== "flex") openModal();
}

closeScanBtn.addEventListener("click", () => {
  closeModal();
  setScanning(false);
});
clearScanBtn.addEventListener("click", () => { scannedSeqs = []; renderScannedList(); });

function showToast(message, type = "info", duration = 4000) {
  const container = document.getElementById("toastContainer");
  container.innerHTML = "";
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;
  toast.textContent = message;
  container.appendChild(toast);
  setTimeout(() => toast.classList.add("show"), 50);
  setTimeout(() => {
    toast.classList.remove("show");
    setTimeout(() => toast.remove(), 400);
  }, duration);
}

submitScanBtn.addEventListener("click", async () => {
  if (!currentWO) { alert("Please search a Workorder first."); return; }
  if (!scannedSeqs.length) { alert("No scanned sequences."); return; }

  closeModal();
  setScanning(false);
  showLoading();

  let updated = 0, missing = [];
  try {
    for (const seq of scannedSeqs) {
      const qSeq = query(
        collection(db, "tasks"),
        where("wo", "==", currentWO),
        where("seq", "==", seq)
      );
      const snap = await getDocs(qSeq);
      if (snap.empty) {
        missing.push(seq);
        continue;
      }

      // üî• sort if you have line_no field, otherwise natural order
      const tasks = snap.docs
        .map(d => ({ id: d.id, ...d.data() }))
        .sort((a, b) => (a.line_no ?? 0) - (b.line_no ?? 0));

      // ‚úÖ find first open
      const openTask = tasks.find(t => {
        const st = (t.status || "").toLowerCase();
        return st !== "closed" && st !== "completed";
      });

      if (openTask) {
        await updateDoc(doc(db, "tasks", openTask.id), { status: "CLOSED" });
        updated++;

        // also update local cache
        const idx = allDocs.findIndex(d => d.id === openTask.id);
        if (idx !== -1) {
          allDocs[idx] = { ...allDocs[idx], status: "CLOSED" };
        }

        console.log(`‚úÖ Closed ${openTask.reference_task_card} (Seq ${seq})`);
      } else {
        console.log(`‚ö†Ô∏è No open tasks left for Seq ${seq}`);
      }
    }
  } catch (err) {
    console.error(err);
    alert("Error while updating tasks. Please try again.");
  } finally {
    renderRows(allDocs);
    renderPhaseTotals(allDocs);
    hideLoading();
  }

  scannedSeqs = [];
  renderScannedList();

  const msg = [
    `Updated to CLOSED: ${updated}`,
    missing.length ? `Not found for WO ${currentWO}: ${missing.join(", ")}` : null
  ].filter(Boolean).join("\n");

  if (msg) {
    showToast(msg, updated ? "success" : "error");
  } else {
    showToast("No updates performed.", "info");
  }
});


// Initialize scanned list content
renderScannedList();
if (!lastWO) {
  hideLoading();
}

   </script>
  </body>
</html>
 
