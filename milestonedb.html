<!doctype html>
<html lang="en">
<head>
  <script src="auth.js"></script>
  <script>
  requireLogin();
  </script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Real-time Excel → Firestore (Tasks)</title>
  <style>
         :root {
    --bg-top: #0f172a;
    --bg-bottom: #1e3a8a;
    --card: rgba(255,255,255,0.08);
    --muted: #9ca3af;
    --accent: #ffcc00; /* Lufthansa yellow */
    --error: #ef4444;
    --radius: 14px;
  }
    :root { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    body { max-width:1100px; margin:18px auto; padding:18px; }
    h1 { margin:0 0 8px 0; font-size:20px; }
    .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:12px 0; }
    button { padding:8px 12px; border-radius:6px; border:1px solid #bbb; background:#f5f5f5; cursor:pointer; }
    button.primary {  background: linear-gradient(to bottom, var(--bg-top), var(--bg-bottom)); color:white; border-color:#0a66c2; }
    button.danger { background:#ffe6e6; border-color:#ff8b8b; }
    input[type=file] { padding:6px; }
    .status { margin-left:6px; color:#333; font-size:13px; }
    #tasksTable { width:100%; border-collapse:collapse; margin-top:12px; max-height:520px; overflow:auto; display:block; }
    #tasksTable thead { background:#fafafa; position:sticky; top:0; z-index:2; }
    #tasksTable th, #tasksTable td { padding:6px 8px; border:1px solid #eee; text-align:left; font-size:13px; }
    #tasksTable tbody tr:nth-child(odd) { background:#fff; }
    #tasksTable tbody tr:nth-child(even) { background:#fbfbfb; }
    .small { font-size:13px; color:#666; }
        .logout-btn {
     background: linear-gradient(to bottom, var(--bg-top), var(--bg-bottom));   /* blue background */
      color: rgb(244, 236, 236);          /* white text */
      padding: 8px 16px;     /* spacing */
      border:#f4f4f4;          /* no border */
      border-radius: 8px;    /* rounded corners */
      cursor: pointer;       /* pointer on hover */
      font-size: 14px;
      text-align: center;
      float: right;
      width: 120px;
    }

    .logout-btn:hover {
     
     background: var(--accent); 
    }

  </style>
</head>
<body>
  <div <button onclick="logout()" class="logout-btn">Logout </button> </div>  
  <h1>Real-time Excel → Milestone Database</h1>
  <div class="small">Uploads Excel rows to Milestone database (collection: <code>tasks</code>) using <code>taskid</code> as document ID. Live updates via Web milestone plan onSnapshot.</div>

    <div class="controls">
      <input id="file" type="file" accept=".xlsx,.xls,.csv" />
      <button id="uploadBtn" class="primary">Upload to Firestore</button>
      <label for="workorderSelect">Select Workorder:</label>
      <select id="workorderSelect"></select>
      <button id="deleteWorkorderBtn" class="danger">Delete Workorder</button>
      <button id="downloadWorkorderBtn" class="primary">
        Download Workorder
      </button>
      <label style="margin-left: 8px">
        <input id="useRemote" type="checkbox" checked /> Use Firestore (remote)
      </label>
      <span class="status" id="status">Initializing Firebase...</span>
    </div>

  <div style="flex:1 1 100%;">
    <table id="tasksTable" aria-label="Tasks table">
      <thead>
        <tr id="headerRow"></tr>
      </thead>
      <tbody id="tasksBody">
        <tr><td colspan="12" class="small">No tasks loaded yet.</td></tr>
      </tbody>
    </table>
  </div>

  <!-- SheetJS for parsing -->
  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>

  <script 
      const SESSION_KEY = "demo_session";
  const savedSession = JSON.parse(localStorage.getItem(SESSION_KEY) || sessionStorage.getItem(SESSION_KEY));

  if (!savedSession) {
    location.href = "index.html"; // not logged in
  } else {
    // Role-based access check
    const page = location.pathname.split("/").pop(); // current file name
    if (savedSession.page !== page) {
      location.href = "index.html"; // redirect if wrong user for this page
    }
  }
    type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
      import {
        getFirestore,
        collection,
        doc,
        writeBatch,
        onSnapshot,
        query,
        where,
        orderBy,
        getDocs,
        serverTimestamp,
      } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";
      import {
        getAuth,
        signInAnonymously,
      } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

      const firebaseConfig = {
        apiKey: "AIzaSyCUNjFesHA_nMEsULylFlEdNZHy-MlT7_o",
        authDomain: "webmilestoneplan.firebaseapp.com",
        projectId: "webmilestoneplan",
        storageBucket: "webmilestoneplan.firebasestorage.app",
        messagingSenderId: "757067401738",
        appId: "1:757067401738:web:697d0440b4aa7264562df3",
      };

      let app, db, auth;
      let firebaseReady = false;

      const fileInput = document.getElementById("file");
      const uploadBtn = document.getElementById("uploadBtn");
      const statusSpan = document.getElementById("status");
      const tasksBody = document.getElementById("tasksBody");
      const headerRow = document.getElementById("headerRow");
      const useRemote = document.getElementById("useRemote");

      const TASKS_COLLECTION = "tasks";
      const BATCH_LIMIT = 500;

      function setStatus(msg, isError = false) {
        statusSpan.textContent = msg;
        statusSpan.style.color = isError ? "crimson" : "#333";
      }

      function normalizeDate(value) {
        if (value == null) return null;
        if (Object.prototype.toString.call(value) === "[object Date]") {
          if (isNaN(value)) return null;
          const y = value.getFullYear();
          const m = String(value.getMonth() + 1).padStart(2, "0");
          const d = String(value.getDate()).padStart(2, "0");
          return `${y}-${m}-${d}`;
        }
        if (typeof value === "number") {
          const excelEpoch = new Date(1899, 11, 30);
          const dt = new Date(excelEpoch.getTime() + value * 86400000);
          return `${dt.getFullYear()}-${String(dt.getMonth() + 1).padStart(
            2,
            "0"
          )}-${String(dt.getDate()).padStart(2, "0")}`;
        }
        const maybe = new Date(value);
        if (!isNaN(maybe)) {
          return `${maybe.getFullYear()}-${String(
            maybe.getMonth() + 1
          ).padStart(2, "0")}-${String(maybe.getDate()).padStart(2, "0")}`;
        }
        return String(value);
      }

      async function parseFileToRows(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const wb = XLSX.read(e.target.result, { type: "binary" });
              const sheet = wb.Sheets[wb.SheetNames[0]];
              const rows = XLSX.utils.sheet_to_json(sheet, { defval: null });
              resolve(rows);
            } catch (err) {
              reject(err);
            }
          };
          reader.onerror = reject;
          reader.readAsBinaryString(file);
        });
      }

      function mapRow(raw) {
        const mapKey = (names) => {
          const keys = Object.keys(raw);
          for (const n of names) {
            const found = keys.find(
              (k) => k.trim().toLowerCase() === n.toLowerCase()
            );
            if (found) return found;
          }
          return null;
        };
        return {
          taskid: raw[mapKey(["ID", "taskid"])] ?? null, // 👈 Pull ID column from Excel
          skill: raw[mapKey(["Skill", "skill"])] ?? null,

          sdate: normalizeDate(
            raw[mapKey(["sdate", "Scheduled Start"])] ?? null
          ),
          edate: normalizeDate(raw[mapKey(["Scheduled End", "edate"])] ?? null),
          rev_sdate: normalizeDate(
            raw[mapKey(["rev_sdate", "Revised Start"])] ?? null
          ),
          rev_edate: normalizeDate(
            raw[mapKey(["Revised End", "rev_edate"])] ?? null
          ),
          tasktitle: raw[mapKey(["Task Title", "tasktitle"])] ?? null,
          remarks: raw[mapKey(["remarks", "Remarks"])] ?? null,
          status: raw[mapKey(["status", "Status"])] ?? null,
          acreg: raw[mapKey(["Aircraft", "acreg"])] ?? null,
          workorder: raw[mapKey(["Work Order", "workorder"])] ?? null,
          bay: raw[mapKey(["bay", "AO"])] ?? null,
        };
      }

      const HEADER_LABELS = {
        taskid: "ID", // 👈 New column
        skill: "Skill",
        sdate: "Scheduled Start",
        edate: "Scheduled End",
        rev_sdate: "Revised Start",
        rev_edate: "Revised End",
        tasktitle: "Task Title",
        remarks: "Remarks",
        status: "Status",
        acreg: "Aircraft",
        workorder: "Work Order",
        bay: "AO",
      };

      function renderTable(rows) {
        const headers = Object.keys(HEADER_LABELS);
        rows = [...rows].sort(
          (a, b) =>
            new Date(a.sdate || "2100-01-01") -
            new Date(b.sdate || "2100-01-01")
        );
        headerRow.innerHTML = "";
        headers.forEach((h) => {
          const th = document.createElement("th");
          th.textContent = HEADER_LABELS[h];
          headerRow.appendChild(th);
        });
        tasksBody.innerHTML = "";
        if (!rows.length) {
          tasksBody.innerHTML = `<tr><td colspan="${headers.length}" class="small">No tasks found.</td></tr>`;
          return;
        }
        rows.forEach((r) => {
          const tr = document.createElement("tr");
          headers.forEach((h) => {
            const td = document.createElement("td");
            td.textContent = r[h] ?? "";
            tr.appendChild(td);
          });
          tasksBody.appendChild(tr);
        });
        populateWorkorderDropdown();
      }

      async function uploadRowsToFirestore(mappedRows) {
        if (!firebaseReady) throw new Error("Firebase not ready");

        const totalRows = mappedRows.length;
        const totalChunks = Math.ceil(totalRows / BATCH_LIMIT);
        let uploaded = 0;

        setStatus("⏳ Fetching existing Firestore tasks...");

        // ✅ STEP 1: Read all existing tasks once for efficiency
        const existingDocsSnap = await getDocs(
          collection(db, TASKS_COLLECTION)
        );
        const existingMap = {};
        existingDocsSnap.forEach((d) => {
          existingMap[d.id] = d.data(); // Use Firestore doc ID (taskid)
        });

        console.log(
          `Fetched ${existingDocsSnap.size} existing tasks from Firestore`
        );

        // ✅ STEP 2: Process upload in batches
        for (let i = 0; i < totalChunks; i++) {
          const start = i * BATCH_LIMIT;
          const end = start + BATCH_LIMIT;
          const chunk = mappedRows.slice(start, end);
          const batch = writeBatch(db);

          for (const row of chunk) {
            if (!row.taskid) {
              console.warn("Row missing ID, skipping:", row);
              continue;
            }

            const docId = String(row.taskid);
            const existing = existingMap[docId];

            // 🚫 Skip if Firestore already has it and it's Closed
            if (
              existing &&
              String(existing.status).toLowerCase() === "closed"
            ) {
              console.log(`⏭️ Skipping closed task: ${docId}`);
              continue;
            }

            // ✅ Create or update (merge)
            batch.set(
              doc(db, TASKS_COLLECTION, docId),
              {
                ...row,
                updatedAt: serverTimestamp(),
              },
              { merge: true }
            );
          }

          setStatus(
            `⏳ Uploading batch ${
              i + 1
            }/${totalChunks}... (${uploaded}/${totalRows})`
          );
          await batch.commit();

          uploaded += chunk.length;
          setStatus(
            `✅ Batch ${
              i + 1
            }/${totalChunks} committed (${uploaded}/${totalRows})`
          );
          console.log(`✅ Batch ${i + 1}/${totalChunks} done`);
        }

        setStatus(
          `🎉 Upload complete! (${uploaded}/${totalRows} rows processed)`
        );
      }

      function attachRealtimeListener() {
        const q = query(collection(db, TASKS_COLLECTION), orderBy("sdate"));
        onSnapshot(
          q,
          (snapshot) => {
            const rows = [];
            snapshot.forEach((docSnap) => rows.push(docSnap.data()));
            renderTable(rows);
            setStatus(`Realtime: ${rows.length} tasks`);
          },
          (err) => setStatus("Listener error: " + err.message, true)
        );
      }

      uploadBtn.addEventListener("click", async () => {
        const file = fileInput.files?.[0];
        if (!file) return setStatus("Select file", true);
        const rows = (await parseFileToRows(file)).map((r) => mapRow(r));
        if (useRemote.checked) await uploadRowsToFirestore(rows);
        else setStatus("Remote disabled (no upload)");
      });

      try {
        app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);
        signInAnonymously(auth)
          .then(() => {
            setStatus("Signed in (anonymous)");
            firebaseReady = true;
            attachRealtimeListener();
          })
          .catch((err) => setStatus("Auth failed: " + err.message, true));
      } catch (e) {
        setStatus("Firebase init failed: " + e.message, true);
      }

      async function populateWorkorderDropdown() {
        const snap = await getDocs(collection(db, TASKS_COLLECTION));
        const workorders = new Set();
        snap.forEach((d) => {
          if (d.data().workorder !== undefined && d.data().workorder !== null) {
            workorders.add(d.data().workorder);
          }
        });
        const select = document.getElementById("workorderSelect");
        select.innerHTML = "";
        if (workorders.size === 0) {
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "No workorders found";
          select.appendChild(opt);
          select.disabled = true;
        } else {
          workorders.forEach((workorder) => {
            const opt = document.createElement("option");
            opt.value = workorder;
            opt.textContent = workorder;
            select.appendChild(opt);
          });
          select.disabled = false;
        }
      }
      populateWorkorderDropdown();

      deleteWorkorderBtn.addEventListener("click", async () => {
        const select = document.getElementById("workorderSelect");
        let workorder1 = select.value;
        if (!workorder1) return setStatus("Please select a workorder", true);
        let q = query(
          collection(db, TASKS_COLLECTION),
          where("workorder", "==", workorder1)
        );
        let snap = await getDocs(q);
        if (snap.empty && !isNaN(workorder1)) {
          q = query(
            collection(db, TASKS_COLLECTION),
            where("workorder", "==", Number(workorder1))
          );
          snap = await getDocs(q);
        }
        if (snap.empty) {
          return setStatus(
            `No tasks found for Workorder "${workorder1}"`,
            true
          );
        }
        const docs = snap.docs;
        const count = docs.length;
        if (!confirm(`Delete ${count} task(s) for Workorder "${workorder1}"?`))
          return;
        for (let i = 0; i < docs.length; i += BATCH_LIMIT) {
          const batch = writeBatch(db);
          docs.slice(i, i + BATCH_LIMIT).forEach((d) => batch.delete(d.ref));
          await batch.commit();
        }
        setStatus(`Deleted ${count} task(s) for Workorder "${workorder1}"`);
        populateWorkorderDropdown();
      });

      const downloadWorkorderBtn = document.getElementById(
        "downloadWorkorderBtn"
      );

      downloadWorkorderBtn.addEventListener("click", async () => {
        const select = document.getElementById("workorderSelect");
        const workorder = select.value;

        if (!workorder) {
          setStatus("Please select a workorder to download", true);
          return;
        }

        setStatus(`Fetching tasks for Workorder "${workorder}"...`);

        try {
          const rows = [];

          // 🔍 Query 1: workorder stored as STRING
          const qString = query(
            collection(db, TASKS_COLLECTION),
            where("workorder", "==", workorder)
          );
          const snapString = await getDocs(qString);
          snapString.forEach((docSnap) => rows.push(docSnap.data()));

          // 🔍 Query 2: workorder stored as NUMBER
          if (!isNaN(workorder)) {
            const qNumber = query(
              collection(db, TASKS_COLLECTION),
              where("workorder", "==", Number(workorder))
            );
            const snapNumber = await getDocs(qNumber);
            snapNumber.forEach((docSnap) => rows.push(docSnap.data()));
          }

          // 🧩 Remove duplicates (if both queries returned same docs)
          const seen = new Set();
          const uniqueRows = rows.filter((r) => {
            if (seen.has(r.taskid)) return false;
            seen.add(r.taskid);
            return true;
          });

          if (!uniqueRows.length) {
            setStatus(`No tasks found for "${workorder}"`, true);
            return;
          }

          // 🗓️ Sort by scheduled start
          uniqueRows.sort(
            (a, b) =>
              new Date(a.sdate || "2100-01-01") -
              new Date(b.sdate || "2100-01-01")
          );

          // 🧾 Format data for Excel with readable headers
          const headers = Object.keys(HEADER_LABELS);
          const exportData = uniqueRows.map((r) =>
            Object.fromEntries(
              headers.map((h) => [HEADER_LABELS[h], r[h] ?? ""])
            )
          );

          // 📘 Create Excel sheet and trigger download
          const ws = XLSX.utils.json_to_sheet(exportData);
          const wb = XLSX.utils.book_new();
          XLSX.utils.book_append_sheet(wb, ws, `Workorder_${workorder}`);

          const fileName = `Workorder_${workorder}_${
            new Date().toISOString().split("T")[0]
          }.xlsx`;

          XLSX.writeFile(wb, fileName);
          setStatus(
            `✅ Downloaded ${uniqueRows.length} task(s) for "${workorder}"`
          );
        } catch (err) {
          console.error(err);
          setStatus("Download failed: " + err.message, true);
        }
      });

  </script>
</body>
</html>
