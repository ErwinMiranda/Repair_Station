<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="auth.js"></script>
    <script>
      requireLogin();
    </script>
    <meta charset="utf-8" />
    <title>Web Based MilestonePlan</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      :root {
        --bg-top: #05164d; /* Lufthansa Blue */
        --bg-bottom: #05164d; /* Set to same for a solid header */
        --card: rgba(255, 255, 255, 0.08);
        --muted: #d1d5db; /* A cleaner light gray */
        --accent: #ffb900; /* Lufthansa Yellow */
        --error: #ef4444;
        --radius: 14px;
      }
      /* --- trimmed / same style as you provided with minor adjustments --- */
      body {
        font-family: Arial, sans-serif;
        padding: 18px;
        margin: 0;
        background: #fafafa;
      }
      .plan-header {
        position: sticky;
        top: 0;
        z-index: 100;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: linear-gradient(to bottom, var(--bg-top), var(--bg-bottom));
        padding: 8px 12px;
        border-radius: var(--radius);
      }

      .plan-heading {
        font-size: 18px;
        font-weight: 700;
        color: #d0d0d0;
      }

      #controls {
        position: sticky;
        top: 47px;
        z-index: 100;
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 10px;
        margin-top: 10px;
        background: #ffffff;
        height: 50px;
        border-bottom: 1px solid #ccc;
      }

      #matrix-container {
        overflow: auto;
        border: 1px solid #ddd;
        background: #fff;
        border-radius: 6px;
        height: 85vh;
      }
      table {
        width: 100%;
        border-spacing: 0;
        min-width: 1000px;
        border-collapse: separate;
        border: 1px solid #ccc;
      }
      th,
      td {
        padding: 0;
        min-width: 120px;
        border-left: 1px solid #ccc;
        border-right: 1px solid #ccc;
        box-sizing: border-box;
      }
      th {
        background: #f4f4f4;
        padding: 6px;
        border-bottom: 2px solid #ccc;
        position: sticky;
        top: 0;
        z-index: 21;
      }
      tr.skill-row td {
        background: #ecf0f1;
        padding: 8px 12px;
        font-weight: 700;
        text-align: left;
        cursor: pointer;
        position: sticky;
        left: 0;
        z-index: 6;
      }
      table th:first-child,
      table td:first-child {
        position: sticky;
        left: 0;
        z-index: 14;
        background: #ffffff;
        border-right: 1px solid #ccc;
      }
      .sunday {
        background: #fccc7869;
      }
      .open {
        background: #fbffd6;
      }
      .closed {
        background: #d4f7d4;
      }
      .cell-wrapper {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 6px;
        height: 42px;
        position: relative;
      }
      .glow-line {
        position: absolute;
        top: 50%;
        height: 2px;
        width: 100%;
        z-index: 1;
        transform: translateY(-50%);
      }
      .start-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 3;
      }
      .task-block {
        padding: 4px 6px;
        border-radius: 4px;
        border: 2px solid #ccc;
        background: white;
        font-size: 12px;
        cursor: grab;
        height: 100%;
        width: 100%;
        display: block;
        position: relative;
        z-index: 2;
        box-sizing: border-box;
      }
      .task-block.advance {
        border-color: rgb(2, 255, 2);
        animation: pulseGreen 2s infinite;
      }
      .task-block.delay {
        border-color: rgb(255, 0, 0);
        animation: pulseRed 2s infinite;
      }
      .task-block.ontime {
        border-color: gray;
      }
      @keyframes pulseRed {
        0% {
          box-shadow: 0 0 4px red;
        }
        50% {
          box-shadow: 0 0 12px red;
        }
        100% {
          box-shadow: 0 0 4px red;
        }
      }
      @keyframes pulseGreen {
        0% {
          box-shadow: 0 0 4px rgb(1, 245, 1);
        }
        50% {
          box-shadow: 0 0 12px rgb(0, 255, 0);
        }
        100% {
          box-shadow: 0 0 4px rgb(2, 248, 2);
        }
      }
      td.drop-target {
        outline: 3px dashed rgba(52, 152, 219, 0.6);
      }
      /* Modal & remarks editor */
      .modal {
        position: fixed;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.7);
        z-index: 9999;
      }
      .modal .card {
        width: 760px;
        background: white;
        padding: 12px;
        border-radius: 8px;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
      }
      .form-row {
        display: flex;
        gap: 8px;
        margin-bottom: 8px;
      }
      label {
        font-size: 12px;
        color: #333;
        margin-bottom: 4px;
        display: block;
      }
      input[type="text"],
      input[type="date"],
      textarea,
      select {
        padding: 6px;
        width: 100%;
        box-sizing: border-box;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 13px;
      }
      textarea {
        resize: vertical;
        min-height: 60px;
      }
      .modal .actions {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        margin-top: 10px;
      }
      button {
        padding: 6px 10px;
        border-radius: 6px;
        border: none;
        cursor: pointer;
      }

      .primary {
        background: var(--accent);
        color: #000;
      }
      .secondary {
        background: #3b82f6; /* A standard blue */
        color: #fff;
      }
      .danger {
        background: #e74c3c;
        color: #fff;
      }
      .muted {
        background: #ddd;
      }
      #remarks-editor {
        position: absolute;
        z-index: 9998;
        display: none;
        background: #fff;
        border: 1px solid #ccc;
        padding: 8px;
        border-radius: 6px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.14);
      }
      .inline-edit {
        outline: 1px dashed rgba(0, 0, 0, 0.13);
        padding: 2px 4px;
        border-radius: 3px;
      }
      .glow-span {
        position: absolute;
        top: 50%;
        left: 0;
        height: 2px;
        width: 100%;
        transform: translateY(-50%);
      }

      .glow-advance {
        background-color: #8ac08d;
      }
      .glow-delay {
        background-color: #e08b8b;
      }
      .glow-ontime {
        background-color: #d0d0d0;
      }

      .start-dot {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        transform: translate(-50%, -50%);
      }

      .dot-advance {
        background-color: #1ff129;
      }
      .dot-delay {
        background-color: #f02929;
      }
      .dot-ontime {
        background-color: #d0d0d0;
      }
      .task-block {
        position: relative;
        z-index: 2;
      }

      .glow-span,
      .start-dot {
        z-index: 1;
      }
      td {
        position: relative;
      }
      .half-glow {
        position: absolute;
        top: 50%;
        height: 2px;
        width: 50%;
        transform: translateY(-50%);
      }

      .half-glow.right {
        left: 50%;
      }
      .half-glow.left {
        left: 0;
      }
      .skill-row {
        background: #a3a0a0;
        z-index: 6;
        position: relative;
      }
      .task-selected {
        outline: 2px solid blue;
      }
      .today-highlight {
        background: #2b8aff53;
      }
      .logout-btn {
        background: linear-gradient(
          to bottom,
          var(--bg-top),
          var(--bg-bottom)
        ); /* blue background */
        color: rgb(244, 236, 236); /* white text */
        padding: 8px 16px; /* spacing */
        border: #f4f4f4; /* no border */
        border-radius: 8px; /* rounded corners */
        cursor: pointer; /* pointer on hover */
        font-size: 14px;
      }

      .logout-btn:hover {
        background: var(--accent);
      }
      @keyframes bounceInvalid {
        0% {
          transform: translateX(0);
          background-color: red;
        }
        25% {
          transform: translateX(-6px);
          background-color: red;
        }
        50% {
          transform: translateX(6px);
        }
        75% {
          transform: translateX(-4px);
        }
        100% {
          transform: translateX(0);
        }
      }

      td.bounce {
        animation: bounceInvalid 0.3s ease;
      }
      .legend-container {
        display: flex;
        align-items: center;
        gap: 15px; /* Space between legend items */
        padding: 0 10px;
      }
      .legend-item {
        display: flex;
        align-items: center;
        gap: 5px; /* Space between swatch and label */
      }
      .legend-swatch {
        width: 14px;
        height: 14px;
        border: 1px solid #ccc;
        border-radius: 2px;
        box-sizing: border-box;
      }
      .legend-label {
        font-size: 12px;
        color: #333;
      }

      /* --- Swatch-Specific Colors --- */
      .swatch-open {
        background-color: #fdfbbe;
      }
      .swatch-closed {
        background-color: #e7fafe;
      }
      .swatch-delay {
        background-color: #fdfbbe; /* Open task */
        border: 2px solid rgb(255, 0, 0); /* Delay border */
      }
      .swatch-advance {
        background-color: #fdfbbe; /* Open task */
        border: 2px solid rgb(2, 255, 2); /* Advance border */
      }
      .swatch-today {
        background-color: #2b8aff53; /* Today highlight */
      }
      .swatch-sunday {
        background-color: #fccc7869; /* Sunday highlight */
      }
      .history-line {
        position: absolute;
        top: 50%;
        height: 2px;
        width: 100%;
        z-index: 1;
        transform: translateY(-50%);
        background-color: #cccccc; /* Light static gray */
      }
      .half-history-line {
        position: absolute;
        top: 50%;
        height: 2px;
        width: 50%;
        transform: translateY(-50%);
        background-color: #cccccc;
      }

      .half-history-line.right {
        left: 50%;
      }
      .half-history-line.left {
        left: 0;
      }
      .dot-history {
        background-color: #cccccc; /* Matches the history-line color */
      }
      /* --- PRINT STYLES --- */
      @media print {
        @page {
          size: landscape;
          margin: 5mm;
        }
        body {
          padding: 0;
          background: white;
        }
        /* Hide non-printable UI */
        #controls,
        .logout-btn,
        .print-btn,
        .modal,
        #remarks-editor {
          display: none !important;
        }

        /* Adjust Header for paper */
        .plan-header {
          position: relative !important;
          background: none !important;
          color: black !important;
          border: none;
          padding: 0;
          margin-bottom: 10px;
        }
        .plan-heading {
          color: black !important;
          font-size: 20px;
        }

        /* Expand the container to fit all content (remove scroll) */
        #matrix-container {
          height: auto !important;
          overflow: visible !important;
          border: none;
          width: 100%;
        }

        /* Remove Sticky positioning (causes glitches in PDF/Print) */
        th,
        tr.skill-row td,
        table th:first-child,
        table td:first-child {
          position: static !important;
        }

        /* FORCE Background Colors (Chrome/Edge/Safari) */
        * {
          -webkit-print-color-adjust: exact !important;
          print-color-adjust: exact !important;
        }
      }
      .print-btn {
        background: #fff;
        color: var(--bg-top); /* Lufthansa Blue text */
        padding: 8px 16px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        margin-left: 10px; /* Space from Logout button */
        font-weight: bold;
      }
      .print-btn:hover {
        background: #e0e0e0;
      }
      .legend-label {
        font-size: 12px;
        color: #333;
      }
      .queue-item {
        font-size: 13px;
        background: #fff;
        border: 1px solid #ccc;
        padding: 4px 8px;
        margin-bottom: 5px;
        border-radius: 3px;
        display: flex;
        justify-content: space-between;
      }
      .queue-item span {
        color: #555;
      }
      .skill-row {
        border-top: 4px solid #000 !important; /* thick separator */
      }
    </style>
  </head>
  <body>
    <div class="plan-header">
      <div class="plan-heading" id="date-range-heading">Loading‚Ä¶</div>
      <div>
        <button onclick="logout()" class="logout-btn">Logout</button>
        <button onclick="window.print()" class="print-btn">Print / PDF</button>
      </div>
    </div>

    <div id="controls">
      <label for="wo-filter" style="padding-top: 4px">Select WO:</label>
      <select id="wo-filter" style="width: 160px"></select>
      <button id="wo-search">Search</button>
      <button
        id="open-batch-add-btn"
        style="margin-left: 10px; background: #28a745; color: white"
      >
        Batch Add Milestone
      </button>
      <div
        style="
          flex: 1;
          display: flex;
          justify-content: right;
          align-items: center;
          min-width: 400px;
        "
      >
        <div class="legend-container">
          <div class="legend-item">
            <span class="legend-swatch swatch-open"></span>
            <span class="legend-label">Open</span>
          </div>
          <div class="legend-item">
            <span class="legend-swatch swatch-closed"></span>
            <span class="legend-label">Closed</span>
          </div>
          <div class="legend-item">
            <span class="legend-swatch swatch-advance"></span>
            <span class="legend-label">Advance</span>
          </div>
          <div class="legend-item">
            <span class="legend-swatch swatch-delay"></span>
            <span class="legend-label">Delay</span>
          </div>
          <div class="legend-item">
            <span class="legend-swatch swatch-today"></span>
            <span class="legend-label">Today</span>
          </div>
          <div class="legend-item">
            <span class="legend-swatch swatch-sunday"></span>
            <span class="legend-label">Sunday &nbsp;</span>
          </div>
        </div>
      </div>
      <div
        id="status-indicator"
        style="font-size: 13px; color: #363434; padding-right: 5px"
      >
        Firestore: connecting‚Ä¶
      </div>
    </div>

    <div style="margin-bottom: 10px"></div>
    <!-- Skill Filter Toolbar -->
    <div
      id="skill-toolbar"
      style="display: flex; gap: 6px; margin-bottom: 6px; flex-wrap: wrap"
    ></div>

    <div id="matrix-container"></div>

    <!-- Modal for create/edit -->
    <div id="task-modal" class="modal" role="dialog">
      <div class="card">
        <h3 id="modal-title">Edit Milestone</h3>
        <div class="form-row">
          <div style="flex: 1">
            <label>Milestone ID (optional)</label>
            <input
              id="f-taskid"
              type="text"
              placeholder="taskid or leave blank to auto"
            />
          </div>
          <div style="flex: 1">
            <label>Skill</label>
            <input id="f-skill" type="text" />
          </div>
        </div>
        <div class="form-row">
          <div style="flex: 1">
            <label>Planned Start (sdate)</label>
            <input id="f-sdate" type="date" />
          </div>
          <div style="flex: 1">
            <label>Planned End (edate)</label>
            <input id="f-edate" type="date" />
          </div>
        </div>
        <div class="form-row">
          <div style="flex: 1">
            <label>Revised Start (rev_sdate)</label>
            <input id="f-rev_sdate" type="date" />
          </div>
          <div style="flex: 1">
            <label>Revised End (rev_edate)</label>
            <input id="f-rev_edate" type="date" />
          </div>
        </div>
        <div class="form-row">
          <div style="flex: 1">
            <label>Title</label>
            <input id="f-tasktitle" type="text" />
          </div>
          <div style="flex: 1">
            <label>A/C Reg</label>
            <input id="f-acreg" type="text" readonly />
          </div>
        </div>
        <div>
          <label>Remarks</label>
          <textarea id="f-remarks"></textarea>
        </div>
        <div class="form-row">
          <div style="flex: 1">
            <label>Status</label>
            <div style="display: flex; gap: 15px; padding-top: 6px">
              <label
                style="
                  display: flex;
                  align-items: center;
                  gap: 5px;
                  font-weight: normal;
                  margin: 0;
                  cursor: pointer;
                "
              >
                <input
                  type="radio"
                  name="status_radio"
                  id="f-status-open"
                  value="open"
                  checked
                />
                Open
              </label>
              <label
                style="
                  display: flex;
                  align-items: center;
                  gap: 5px;
                  font-weight: normal;
                  margin: 0;
                  cursor: pointer;
                "
              >
                <input
                  type="radio"
                  name="status_radio"
                  id="f-status-closed"
                  value="Closed"
                />
                Closed
              </label>
            </div>
          </div>
          <div style="flex: 1">
            <label>Workorder</label>
            <input id="f-workorder" type="text" readonly />
          </div>
        </div>
        <div class="actions">
          <button id="delete-task-btn" class="danger">Delete</button>
          <button id="cancel-modal" class="muted">Cancel</button>
          <button id="save-modal" class="primary">Save</button>
        </div>
      </div>
    </div>
    <!-- Bulk Action Modal (Replan or Close) -->
    <div id="bulk-action-modal" class="modal" role="dialog">
      <div class="card" style="width: 400px">
        <h3 id="bulk-action-title">Bulk Action</h3>
        <div style="margin-bottom: 8px">
          <label for="bulk-action-date">Action Date</label>
          <input
            id="bulk-action-date"
            type="date"
            style="width: 100%; box-sizing: border-box; padding: 6px"
          />
        </div>
        <div>
          <label for="bulk-action-remarks">Remarks</label>
          <textarea
            id="bulk-action-remarks"
            style="width: 100%; min-height: 80px"
          ></textarea>
        </div>
        <div class="actions">
          <button id="bulk-action-cancel" class="muted">Cancel</button>
          <button
            id="bulk-edit-details"
            class="muted"
            style="margin-right: auto"
          >
            Edit Details
          </button>
          <button id="bulk-new-plan-confirm" class="primary">New Plan</button>
          <button id="bulk-replan-confirm" class="secondary">
            Confirm Replan
          </button>
          <button id="bulk-close-confirm" class="danger">Confirm Close</button>
        </div>
      </div>
    </div>
    <div id="batch-add-modal" class="modal" role="dialog">
      <div class="card" style="width: 700px">
        <h3>Batch Add Milestone</h3>
        <p style="font-size: 13px; color: #333; margin-top: 0">
          Add milestone to the queue. They will all be saved to the current Work
          Order when you click "Save All".
        </p>

        <div class="form-row" style="align-items: flex-end">
          <div style="flex: 2">
            <label>Milestone Title</label>
            <input id="b-tasktitle" type="text" />
          </div>
          <div style="flex: 1">
            <label>Skill</label>
            <select id="b-skill"></select>
          </div>
          <button id="add-to-queue-btn" type="button" class="secondary">
            Add to Queue
          </button>
        </div>
        <div class="form-row">
          <div style="flex: 1">
            <label>Start Date</label>
            <input id="b-sdate" type="date" />
          </div>
          <div style="flex: 1">
            <label>End Date</label>
            <input id="b-edate" type="date" />
          </div>
        </div>

        <hr style="margin: 15px 0" />

        <label>Milestone Queue (<span id="queue-count">0</span>)</label>
        <div
          id="task-queue-list"
          style="
            max-height: 200px;
            overflow-y: auto;
            background: #f9f9f9;
            border: 1px solid #ddd;
            padding: 8px;
            border-radius: 4px;
            min-height: 50px;
          "
        ></div>

        <div class="actions">
          <button id="batch-add-cancel" class="muted">Cancel</button>
          <button id="batch-save-all-btn" class="primary">Save All</button>
        </div>
      </div>
    </div>

    <!-- Floating remarks editor -->
    <div id="remarks-editor">
      <textarea id="remarks-text" style="width: 300px; height: 100px"></textarea
      ><br />
      <div
        style="
          display: flex;
          gap: 8px;
          justify-content: flex-end;
          margin-top: 8px;
        "
      >
        <button id="remarks-save" class="primary">Save</button>
        <button id="remarks-cancel" class="muted">Cancel</button>
        <button id="remarks-close-task" class="danger">Close Milestone</button>
      </div>
    </div>

    <!-- Firebase modules -->
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
      import {
        getFirestore,
        collection,
        query,
        orderBy,
        onSnapshot,
        getDocs,
        doc,
        setDoc,
        addDoc,
        updateDoc,
        deleteDoc,
        serverTimestamp,
      } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";
      import {
        getAuth,
        signInAnonymously,
      } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

      // üîë Firebase Config
      const firebaseConfig = {
        apiKey: "AIzaSyCUNjFesHA_nMEsULylFlEdNZHy-MlT7_o",
        authDomain: "webmilestoneplan.firebaseapp.com",
        projectId: "webmilestoneplan",
        storageBucket: "webmilestoneplan.firebasestorage.app",
        messagingSenderId: "757067401738",
        appId: "1:757067401738:web:697d0440b4aa7264562df3",
      };

      // Globals
      let app, db, auth;
      let firestoreConnected = false; // ‚úÖ added flag
      let unsubscribe = null;
      let skillDisplayOrder = []; // Order of skills based on click sequence
      // === Skill Visibility Globals ===
      let collapsedSkills = new Set(); // tracks which skills are hidden
      window.availableSkills = []; // skills currently present in dataset
      window.skillToolbarInitialized = false; // ensures toolbar is built once
      let isBatchSaving = false;
      let editingQueueIndex = null;
      // custom skill order
      const SKILL_ORDER = [
        "SHOP",
        "CAB",
        "AVI",
        "CRG",
        "ENG",
        "FLC",
        "LDG",
        "STR",
      ];
      try {
        app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);

        populateSkillDropdown();

        document.getElementById("status-indicator").innerText =
          "Planning: connecting‚Ä¶";

        signInAnonymously(auth)
          .then(() => {
            firestoreConnected = true;
            console.log("‚úÖ Signed in anonymously");
            document.getElementById("status-indicator").innerText =
              "Planning: signed in";
            startRealtime(); // ‚úÖ only start after signed in
          })
          .catch((err) => {
            console.error("‚ùå Auth failed", err);
            document.getElementById("status-indicator").innerText =
              "Auth failed: " + err.message;
          });
      } catch (err) {
        console.error("Firebase init error", err);
        document.getElementById("status-indicator").innerText =
          "Planning init failed: " + err.message;
      }

      // ---------- helpers for date parsing ----------
      function excelSerialToDate(serial) {
        // Excel serial number to JS Date (handles whole number only)
        const epoch = new Date(Date.UTC(1899, 11, 30)); // Excel epoch
        const days = Math.floor(Number(serial));
        const ms = days * 24 * 60 * 60 * 1000;
        return new Date(epoch.getTime() + ms);
      }

      function parseDateField(val) {
        if (val === undefined || val === null || val === "") return null;
        if (typeof val === "number") return excelSerialToDate(val); // ‚úÖ fixed
        if (!isNaN(Number(val)) && String(val).indexOf("-") === -1) {
          return excelSerialToDate(Number(val));
        }
        const d = new Date(val);
        if (!isNaN(d.getTime())) return d;
        return null;
      }

      function toSerialDayKey(dateObj) {
        const d = new Date(
          Date.UTC(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate())
        );
        return Math.floor(d.getTime() / (24 * 60 * 60 * 1000));
      }
      function dayKeyToDate(dayKey) {
        return new Date(dayKey * 24 * 60 * 60 * 1000);
      }
      function formatDisplayDateShort(dateObj) {
        return dateObj.toLocaleDateString("en-US", {
          month: "short",
          day: "2-digit",
          year: "numeric",
        });
      }
      function weekdayShort(dateObj) {
        return dateObj.toLocaleDateString("en-US", { weekday: "short" });
      }

      // VVVV ADD THIS NEW FUNCTION VVVV
      /**
       * Populates the batch add skill dropdown with the global skill list
       */
      function populateSkillDropdown() {
        const select = document.getElementById("b-skill");
        if (!select) return;

        select.innerHTML = ""; // Clear existing options

        // Add a default "General" option
        const defaultOpt = document.createElement("option");
        defaultOpt.value = "GEN"; // Use "GEN" or "Unassigned"
        defaultOpt.textContent = "GEN";
        select.appendChild(defaultOpt);

        // Add all skills from the global list
        SKILL_ORDER.forEach((skill) => {
          const opt = document.createElement("option");
          opt.value = skill;
          opt.textContent = skill;
          select.appendChild(opt);
        });
      }
      // ^^^^ END OF NEW FUNCTION ^^^^

      // ---------- Firestore collection ----------
      const tasksCol = () => collection(db, "tasks");
      async function populateWorkorderDropdown() {
        const snap = await getDocs(tasksCol());

        // Map workorder ‚Üí acreg
        const woMap = new Map();

        snap.forEach((d) => {
          const data = d.data();
          const wo = String(data.workorder || "").trim();
          const ac = String(data.acreg || "").trim();

          if (wo !== "") {
            woMap.set(wo, ac); // if multiple docs share same workorder, last one wins
          }
        });

        const select = document.getElementById("wo-filter");
        select.innerHTML = "";

        const savedValue = (localStorage.getItem("woFilterValue") || "").trim();

        if (woMap.size === 0) {
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "No workorders found";
          select.appendChild(opt);
          select.disabled = true;
        } else {
          woMap.forEach((acreg, wo) => {
            const opt = document.createElement("option");
            opt.value = wo;
            opt.textContent = wo;
            if (acreg) {
              opt.title = acreg; // <-- this shows on hover
            }
            select.appendChild(opt);
          });

          // preselect saved value
          if (woMap.has(savedValue)) {
            select.value = savedValue;
          }

          select.disabled = false;
        }

        // save on change
        select.onchange = function () {
          localStorage.setItem("woFilterValue", this.value);
        };
      }

      populateWorkorderDropdown();

      // ---------- UI state ----------
      window.currentRows = []; // cached docs as objects { _id, ...fields }

      // ---------- Work Order filter ----------
      let savedValue = localStorage.getItem("woFilterValue");
      let woFilterValue = savedValue || "";

      // ‚úÖ restore filter into input
      if (savedValue) {
        document.getElementById("wo-filter").value = savedValue;
      }

      document.getElementById("wo-search").addEventListener("click", () => {
        woFilterValue = document
          .getElementById("wo-filter")
          .value.trim()
          .toLowerCase();
        localStorage.setItem("woFilterValue", woFilterValue);
        applyWOfilterAndRender();
      });

      function applyWOfilterAndRender() {
        if (!woFilterValue) {
          document.getElementById("date-range-heading").innerText = "";
          document.getElementById("matrix-container").innerHTML =
            '<div style="padding:10px;color:#999">Please enter a Work Order</div>';
          return;
        }

        let filteredRows = window.currentRows.filter((r) =>
          (r.workorder || "").toString().toLowerCase().includes(woFilterValue)
        );

        if (filteredRows.length === 0) {
          document.getElementById("matrix-container").innerHTML =
            '<div style="padding:10px;color:#999">No tasks found for this Work Order</div>';
          document.getElementById("date-range-heading").innerText = "";
          return;
        }

        buildMatrixTable(filteredRows);
      }

      // ---------- Listen real-time ----------
      function startRealtime() {
        const q = query(tasksCol(), orderBy("sdate"));
        unsubscribe = onSnapshot(
          q,
          (snapshot) => {
            const rows = [];
            snapshot.forEach((docSnap) => {
              rows.push({ _id: docSnap.id, ...docSnap.data() });
            });
            // Build rows normally...
            // inside onSnapshot success callback, after building rows:
            window.currentRows = rows;

            // derive current skill set (preserve SKILL_ORDER where possible)
            const skillSet = new Set();
            rows.forEach((r) => skillSet.add(r.skill || "Unassigned"));

            // Build ordered skill list: SKILL_ORDER first, then any extras (stable order)
            const ordered = [];
            SKILL_ORDER.forEach((s) => {
              if (skillSet.has(s)) {
                ordered.push(s);
                skillSet.delete(s);
              }
            });
            [...skillSet].sort().forEach((s) => ordered.push(s)); // add remaining alphabetically

            window.availableSkills = ordered;

            // Render toolbar only once (keeps buttons stable)
            if (!window.skillToolbarInitialized) {
              renderSkillToolbar(window.availableSkills);
              window.skillToolbarInitialized = true;
            }

            // Ensure timeline + render
            ensureTimelineRange(true);
            applyWOfilterAndRender();
          },
          (err) => {
            console.error("onSnapshot error", err);
            document.getElementById("status-indicator").innerText =
              "Firestore: disconnected, retrying‚Ä¶";

            // ‚úÖ auto-retry after 5s
            setTimeout(startRealtime, 5000);
          }
        );
      }

      // ---------- CRUD helpers ----------
      async function createTask(payload) {
        if (!firestoreConnected) {
          console.warn("Firestore not ready");
          return;
        }
        if (payload._id) {
          const ref = doc(db, "tasks", payload._id);
          const copy = { ...payload };
          delete copy._id;
          await setDoc(
            ref,
            { ...copy, updatedAt: serverTimestamp() },
            { merge: true }
          );
          return payload._id;
        } else {
          const r = await addDoc(tasksCol(), {
            ...payload,
            createdAt: serverTimestamp(),
            updatedAt: serverTimestamp(),
          });
          return r.id;
        }
      }
      /**
       * Closes a list of tasks with a specific closing remark.
       * Uses the app's "yesterday" logic for dates.
       */

      // (Place this new function near updateTask, deleteTask, etc.)

      /**
       * Closes a list of tasks with a specific closing remark AND a specific date.
       */
      async function closeTasks(taskIds, closingRemark, closeDateKey) {
        console.log(
          `Closing ${taskIds.length} tasks on dayKey ${closeDateKey}...`
        );

        for (const id of taskIds) {
          const task = window.currentRows.find((r) => r._id === id);
          if (!task) continue;

          // üî• NEW RULE: Do NOT allow closing if ANY parent is still open
          if (
            Array.isArray(task.dependencies) &&
            task.dependencies.length > 0
          ) {
            const parents = task.dependencies
              .map((pid) => window.currentRows.find((t) => t._id === pid))
              .filter(Boolean);

            const openParents = parents.filter(
              (p) => !p.status || p.status.toLowerCase() !== "closed"
            );

            if (openParents.length > 0) {
              const parentNames = openParents
                .map((p) => p.tasktitle || p._id)
                .join(", ");

              alert(
                `‚ùå Cannot close "${task.tasktitle}".\n` +
                  `The following parent tasks are still OPEN:\n` +
                  parentNames
              );

              continue; // ‚õî Skip closing this task
            }
          }

          const revS = parseDateField(task.rev_sdate ?? task.sdate);
          const revE = parseDateField(task.rev_edate ?? task.edate);

          const startKey = revS
            ? toSerialDayKey(revS)
            : toSerialDayKey(parseDateField(task.sdate));
          if (isNaN(startKey)) {
            console.error(`Skipping ${id}, invalid start date.`);
            continue;
          }

          const duration = revE ? toSerialDayKey(revE) - startKey : 0;

          await updateTask(task._id, {
            status: "Closed",
            remarks: closingRemark,
            rev_sdate: dayKeyToISO(closeDateKey), // <-- 3. Use new variable // ensure duration isn't negative
            rev_edate: dayKeyToISO(
              closeDateKey + (duration < 0 ? 0 : duration)
            ), // <-- 3. Use new variable
          });
        }
        console.log("Finished closing tasks.");
      }

      async function updateTask(id, updates) {
        if (!firestoreConnected) {
          console.warn("Firestore not ready");
          return;
        }
        try {
          const ref = doc(db, "tasks", id);
          await updateDoc(ref, { ...updates, updatedAt: serverTimestamp() });
        } catch (err) {
          console.error("updateTask err", err);
        }
      }

      async function deleteTask(id) {
        if (!firestoreConnected) {
          console.warn("Firestore not ready");
          return;
        }
        try {
          await deleteDoc(doc(db, "tasks", id));
        } catch (err) {
          console.error("deleteTask err", err);
        }
      }

      // ---------- Build matrix table ----------
      // store collapsed skills globally

      function buildMatrixTable(rows) {
        // normalize rows
        const normalized = rows.map((r) => {
          const s = parseDateField(r.sdate);
          const e = parseDateField(r.edate);
          const rs = parseDateField(r.rev_sdate ?? r.sdate);
          const re = parseDateField(r.rev_edate ?? r.edate);
          const os = parseDateField(r.orig_sdate);
          return {
            ...r,
            _sdate: s,
            _edate: e,
            _rev_sdate: rs,
            _rev_edate: re,
            _orig_sdate: os,
          };
        });

        // compute min/max from revised FIRST
        const sCandidates = normalized
          .map((r) => r._rev_sdate || r._sdate)
          .filter(Boolean);
        const eCandidates = normalized
          .map((r) => r._rev_edate || r._edate)
          .filter(Boolean);

        if (!sCandidates.length || !eCandidates.length) {
          document.getElementById("matrix-container").innerHTML =
            '<div style="padding:10px">No date data</div>';
          document.getElementById("date-range-heading").innerText =
            "No date range";
          return;
        }

        let minDate = new Date(
          Math.min(...sCandidates.map((d) => d.getTime()))
        );
        let maxDate = new Date(
          Math.max(...eCandidates.map((d) => d.getTime()))
        );

        minDate = new Date(
          minDate.getFullYear(),
          minDate.getMonth(),
          minDate.getDate()
        );
        maxDate = new Date(
          maxDate.getFullYear(),
          maxDate.getMonth(),
          maxDate.getDate()
        );
        window.minDate = minDate;

        // build day keys
        const dayKeys = [];
        for (
          let k = toSerialDayKey(minDate);
          k <= toSerialDayKey(maxDate);
          k++
        ) {
          dayKeys.push(k);
        }

        // heading update
        const acregs = [...new Set(rows.map((r) => r.acreg).filter(Boolean))];
        window.currentAcregs = acregs;

        const todayKey = toSerialDayKey(new Date());
        const startKey = toSerialDayKey(minDate);
        const dayOfPlan = todayKey - startKey + 1;

        document.getElementById("date-range-heading").innerText = `${
          acregs.join(", ") || "Milestone Plan"
        } | TAT: ${dayKeys.length} days (${formatDisplayDateShort(
          minDate
        )} ‚Äì ${formatDisplayDateShort(maxDate)}) | Day ${dayOfPlan}`;

        // group by skill
        const grouped = {};
        normalized.forEach((task) => {
          const sk = task.skill || "Unassigned";
          if (!grouped[sk]) grouped[sk] = [];
          grouped[sk].push(task);
        });

        const sortedGrouped = Object.entries(grouped).sort(([a], [b]) => {
          const ia = skillDisplayOrder.indexOf(a);
          const ib = skillDisplayOrder.indexOf(b);

          if (ia === -1 && ib === -1) {
            // fallback to SKILL_ORDER
            return SKILL_ORDER.indexOf(a) - SKILL_ORDER.indexOf(b);
          }
          if (ia === -1) return 1;
          if (ib === -1) return -1;
          return ia - ib;
        });

        // create table
        const table = document.createElement("table");

        // HEADER ROWS (unchanged)
        const headerRow1 = document.createElement("tr");
        headerRow1.innerHTML = `
        <th rowspan="3" style="min-width:120px; position:sticky; left:0; z-index:24;">
            Skill
        </th>`;
        dayKeys.forEach((k) => {
          const dateObj = dayKeyToDate(k);
          const th = document.createElement("th");
          th.dataset.day = k;
          if (dateObj.getUTCDay() === 0) th.classList.add("sunday");
          th.textContent = formatDisplayDateShort(dateObj);
          th.style.position = "sticky";
          th.style.top = "0";
          th.style.background = "white";
          th.style.zIndex = "10";
          headerRow1.appendChild(th);
        });
        table.appendChild(headerRow1);

        const headerRow2 = document.createElement("tr");
        dayKeys.forEach((k) => {
          const dateObj = dayKeyToDate(k);
          const th = document.createElement("th");
          th.textContent = weekdayShort(dateObj);
          if (dateObj.getUTCDay() === 0) th.classList.add("sunday");
          th.style.position = "sticky";
          th.style.top = "30px";
          th.style.background = "white";
          th.style.zIndex = "9";
          headerRow2.appendChild(th);
        });
        table.appendChild(headerRow2);

        const headerRow3 = document.createElement("tr");
        dayKeys.forEach((k, idx) => {
          const dateObj = dayKeyToDate(k);
          const th = document.createElement("th");
          th.textContent = `Day ${idx + 1}`;
          if (dateObj.getUTCDay() === 0) th.classList.add("sunday");
          th.style.position = "sticky";
          th.style.top = "60px";
          th.style.background = "white";
          th.style.zIndex = "8";
          headerRow3.appendChild(th);
        });
        table.appendChild(headerRow3);

        // ================================
        //  MAIN TASK ROWS (no skill row!)
        // ================================
        sortedGrouped.forEach(([skill, tasks], skillIndex) => {
          const groupId = `skill-${skillIndex}`;

          // INSERT THICK SEPARATOR ROW
          const sepTr = document.createElement("tr");
          sepTr.classList.add("skill-separator-row");

          // ‚Üì KEEP BELOW sticky headers
          sepTr.style.position = "relative";
          sepTr.style.zIndex = "1";
          const sepTd = document.createElement("td");
          sepTd.colSpan = dayKeys.length + 1;
          sepTd.style.borderTop = "1px solid #ccc";
          sepTd.style.padding = "0";
          sepTd.style.height = "0px";
          sepTr.appendChild(sepTd);
          table.appendChild(sepTr);

          // STACK rows
          const stackedRows = [];

          tasks.forEach((task) => {
            const origSKey = task._orig_sdate
              ? toSerialDayKey(task._orig_sdate)
              : null;
            const sKey = task._sdate ? toSerialDayKey(task._sdate) : null;
            const revSKey = task._rev_sdate
              ? toSerialDayKey(task._rev_sdate)
              : sKey;
            const revEKey = task._rev_edate
              ? toSerialDayKey(task._rev_edate)
              : task._edate
              ? toSerialDayKey(task._edate)
              : revSKey;

            const used = new Set();

            // history + glow + block
            if (origSKey !== null && sKey !== null && origSKey !== sKey) {
              const low = Math.min(origSKey, sKey);
              const high = Math.max(origSKey, sKey);
              for (let d = low; d <= high; d++) used.add(d);
            }

            if (sKey !== null && revSKey !== null && sKey !== revSKey) {
              const low = Math.min(sKey, revSKey);
              const high = Math.max(sKey, revSKey);
              for (let d = low; d <= high; d++) used.add(d);
            }

            if (revSKey !== null && revEKey !== null) {
              for (let d = revSKey; d <= revEKey; d++) used.add(d);
            }

            // Try to place into existing stacked rows
            let placed = false;
            for (const rowArr of stackedRows) {
              const conflict = dayKeys.some(
                (dk, idx) => used.has(dk) && rowArr[idx + 1]?.hasChildNodes()
              );
              if (!conflict) {
                insertTaskToRow(rowArr, task, used, dayKeys);
                placed = true;
                break;
              }
            }

            // Create new row if needed
            if (!placed) {
              const rowArr = [];

              // skill cell (first row only)
              if (stackedRows.length === 0) {
                const skillCell = document.createElement("td");
                skillCell.textContent = skill;
                skillCell.dataset.isSkillCell = "true";
                skillCell.style.fontWeight = "bold";
                skillCell.style.background = "#fff";
                skillCell.style.position = "sticky";
                skillCell.style.left = "0";
                skillCell.style.borderRight = "1px solid #ccc";
                skillCell.style.textAlign = "center";
                rowArr.push(skillCell);
              } else {
                rowArr.push(document.createElement("td"));
              }

              for (let i = 0; i < dayKeys.length; i++) {
                rowArr.push(document.createElement("td"));
              }

              insertTaskToRow(rowArr, task, used, dayKeys);
              stackedRows.push(rowArr);
            }
          });

          // append rows
          stackedRows.forEach((rowArr) => {
            const tr = document.createElement("tr");
            tr.dataset.skill = skill;

            // Respect current collapsed state at render-time
            // respect collapsed state
            tr.style.display = collapsedSkills.has(skill) ? "none" : "";

            rowArr.forEach((td) => tr.appendChild(td));
            table.appendChild(tr);
          });
        });

        // cumulative row (unchanged)
        const cumulativeStickyTop = "90px";
        const cumulativeTr = document.createElement("tr");
        cumulativeTr.style.background = "#E9EAF2";
        cumulativeTr.style.position = "sticky";
        cumulativeTr.style.top = cumulativeStickyTop;
        cumulativeTr.style.zIndex = "15"; // ‚≠ê stays above tasks but below headers
        cumulativeTr.style.boxShadow = "0 2px 4px rgba(0,0,0,0.05)"; // optional
        const labelCumTd = document.createElement("td");
        labelCumTd.textContent = "Closed / Total";
        labelCumTd.style.position = "sticky";
        labelCumTd.style.top = cumulativeStickyTop;
        labelCumTd.style.left = "0";
        labelCumTd.style.background = "#E9EAF2";
        labelCumTd.style.zIndex = "16"; // ‚≠ê higher than row to keep sticky
        cumulativeTr.appendChild(labelCumTd);

        // --- NEW cumulative logic ---
        const totalsPerDay = {}; // how many tasks cover each day
        const closedFinishDay = {}; // how many tasks finish (closed) on a specific day

        // 1. Collect per-day totals AND closed finish dates
        normalized.forEach((task) => {
          const rs = task._rev_sdate ? toSerialDayKey(task._rev_sdate) : null;
          const re = task._rev_edate ? toSerialDayKey(task._rev_edate) : null;
          if (rs === null || re === null) return;

          // count tasks covering the day (non-cumulative)
          for (let d = rs; d <= re; d++) {
            totalsPerDay[d] = (totalsPerDay[d] || 0) + 1;
          }

          // mark closed tasks only once ‚Äî on their end day
          if ((task.status || "").toLowerCase() === "closed") {
            closedFinishDay[re] = (closedFinishDay[re] || 0) + 1;
          }
        });

        // 2. Build cumulative row
        let runningTotal = 0;
        let runningClosed = 0;

        dayKeys.forEach((dk) => {
          runningTotal += totalsPerDay[dk] || 0;
          runningClosed += closedFinishDay[dk] || 0;

          const td = document.createElement("td");
          td.textContent = `${runningClosed} / ${runningTotal}`;
          td.style.background = "#E9EAF2";
          td.style.position = "sticky";
          td.style.top = cumulativeStickyTop;
          td.style.textAlign = "center";
          td.style.verticalAlign = "middle";
          cumulativeTr.appendChild(td);
        });

        table.insertBefore(cumulativeTr, table.rows[3]);

        // set dataset.day and attach drop handlers
        const trs = table.querySelectorAll("tr");
        trs.forEach((tr, idx) => {
          if (idx < 3) return;
          const tds = tr.querySelectorAll("td");
          const headerTh = table
            .querySelector("tr:first-child")
            .querySelectorAll("th");

          for (let i = 1; i < tds.length; i++) {
            const hd = headerTh[i];
            if (hd?.dataset?.day) {
              tds[i].dataset.day = hd.dataset.day;
            }
            attachDropHandlersToTd(tds[i]);
          }
        });
        // Re-apply collapse state after rendering
        for (const skill of collapsedSkills) {
          applySkillCollapse(skill);
        }
        const container = document.getElementById("matrix-container");
        container.innerHTML = "";
        container.appendChild(table);
      }

      function renderSkillToolbar(skills) {
        const bar = document.getElementById("skill-toolbar");
        bar.innerHTML = "";

        // keep the same order passed in `skills`
        skills.forEach((skill) => {
          const btn = document.createElement("button");
          btn.dataset.skill = skill;
          btn.textContent = skill;
          btn.style.padding = "4px 10px";
          btn.style.borderRadius = "6px";
          btn.style.cursor = "pointer";
          btn.style.border = "1px solid #cfcfcf";
          btn.style.transition = "background .12s, color .12s";

          // initial style from collapsedSkills set
          const isCollapsed = collapsedSkills.has(skill);
          btn.style.background = isCollapsed ? "#ddd" : "#3b82f6";
          btn.style.color = isCollapsed ? "#333" : "#fff";

          btn.addEventListener("click", () => {
            const skill = btn.dataset.skill;

            // üîÑ Toggle collapsed state
            if (collapsedSkills.has(skill)) {
              collapsedSkills.delete(skill);

              // üîµ If becoming visible ‚Üí add to skillDisplayOrder (at end)
              if (!skillDisplayOrder.includes(skill)) {
                skillDisplayOrder.push(skill);
              }
            } else {
              collapsedSkills.add(skill);

              // ‚ö™ If becoming hidden ‚Üí remove from skillDisplayOrder
              skillDisplayOrder = skillDisplayOrder.filter((s) => s !== skill);
            }

            // üîß Update button color
            const nowCollapsed = collapsedSkills.has(skill);
            btn.style.background = nowCollapsed ? "#ddd" : "#3b82f6";
            btn.style.color = nowCollapsed ? "#333" : "#fff";

            // üîÑ Apply change to table rows
            applySkillCollapse(skill);

            // üëÄ Special case: all skills hidden ‚Üí show message
            const allHidden =
              window.availableSkills.length > 0 &&
              window.availableSkills.every((s) => collapsedSkills.has(s));

            const container = document.getElementById("matrix-container");

            if (allHidden) {
              container.innerHTML =
                '<div style="padding:12px;color:#777">No milestone visible ‚Äî all skills hidden</div>';
            } else {
              // Re-render table with new skillDisplayOrder
              scheduleRender();
            }
          });

          bar.appendChild(btn);
        });
      }

      function updateSkillButtonStyle(btn) {
        const skill = btn.dataset.skill;

        if (collapsedSkills.has(skill)) {
          btn.style.background = "#dddddd"; // hidden
          btn.style.color = "#333";
        } else {
          btn.style.background = "#3b82f6"; // visible
          btn.style.color = "#fff";
        }
      }

      function applySkillCollapse(skill) {
        const rows = document.querySelectorAll(`tr[data-skill="${skill}"]`);

        rows.forEach((tr) => {
          if (collapsedSkills.has(skill)) {
            tr.style.display = "none"; // hide only this skill
          } else {
            tr.style.display = ""; // show only this skill
          }
        });
      }

      function insertTaskToRow(rowTds, task, usedDatesSet, dayKeys) {
        // --- 1. Define all date keys ---
        const origSKey = task._orig_sdate
          ? toSerialDayKey(task._orig_sdate)
          : null;
        const planSKey = task._sdate ? toSerialDayKey(task._sdate) : null;
        const revSKey = task._rev_sdate
          ? toSerialDayKey(task._rev_sdate)
          : planSKey;
        const revEKey = task._rev_edate
          ? toSerialDayKey(task._rev_edate)
          : task._edate
          ? toSerialDayKey(task._edate)
          : revSKey; // --- 2. Calculate DIFF for Advance/Delay (Plan vs Revised) ---

        const diff =
          revSKey !== null && planSKey !== null ? revSKey - planSKey : 0;
        const todayKey = toSerialDayKey(new Date());

        dayKeys.forEach((dk, index) => {
          const td = rowTds[index + 1];
          if (!td) return;
          if (dk === todayKey) {
            td.classList.add("today-highlight");
          }
          if (dayKeyToDate(dk).getUTCDay() === 0) td.classList.add("sunday"); // --- 3. Draw NEW GRAY HISTORY LINE (Original vs Plan) ---

          if (
            origSKey !== null &&
            planSKey !== null &&
            origSKey !== planSKey &&
            dk >= Math.min(origSKey, planSKey) &&
            dk <= Math.max(origSKey, planSKey)
          ) {
            const historyLine = document.createElement("div");
            const isHistoryAdvance = planSKey < origSKey;

            if (dk === origSKey) {
              historyLine.classList.add(
                "half-history-line",
                isHistoryAdvance ? "left" : "right"
              );
            } else if (dk === planSKey) {
              historyLine.classList.add(
                "half-history-line",
                isHistoryAdvance ? "right" : "left"
              );
            } else {
              historyLine.classList.add("history-line");
            }
            td.appendChild(historyLine); // --- NEW: Draw the gray dot at the start of history ---

            if (dk === origSKey) {
              const dot = document.createElement("span");
              dot.classList.add("start-dot", "dot-history");
              td.appendChild(dot);
            }
          } // --- 4. Draw EXISTING GLOW LINE (Plan vs Revised) ---

          if (
            planSKey !== null &&
            revSKey !== null &&
            planSKey !== revSKey &&
            dk >= Math.min(planSKey, revSKey) &&
            dk <= Math.max(planSKey, revSKey)
          ) {
            const glow = document.createElement("div");
            const isStartCell = dk === planSKey;
            const isAdvance = diff < 0;

            if (isStartCell) {
              glow.classList.add("half-glow", isAdvance ? "left" : "right");
            } else {
              glow.classList.add("glow-span");
            }
            glow.classList.add(
              diff < 0
                ? "glow-advance"
                : diff > 0
                ? "glow-delay"
                : "glow-ontime"
            );
            td.appendChild(glow);

            if (dk === planSKey) {
              const dot = document.createElement("span");
              dot.classList.add(
                "start-dot",
                diff < 0 ? "dot-advance" : diff > 0 ? "dot-delay" : "dot-ontime"
              );
              td.appendChild(dot);
            }
          } // --- 5. TASK BLOCK (Renders at Revised position) ---

          if (
            revSKey !== null &&
            revEKey !== null &&
            dk >= revSKey &&
            dk <= revEKey
          ) {
            const taskDiv = document.createElement("div");
            taskDiv.classList.add("task-block");
            taskDiv.style.position = "relative";

            if ((task.status || "").toLowerCase() === "closed") {
              taskDiv.style.backgroundColor = "#E7FAFE";
              taskDiv.style.color = "Black";
            } else {
              taskDiv.style.backgroundColor = "#FDFBBE";
            }

            if (diff < 0) taskDiv.classList.add("advance");
            else if (diff > 0) taskDiv.classList.add("delay");
            else taskDiv.classList.add("ontime");

            let diffText = "";
            if (diff !== null && diff !== 0) {
              diffText = `${Math.abs(diff)} day(s) ${
                diff < 0 ? "advance" : "delay"
              }`;
            } else if (diff === 0) {
              diffText = "On time";
            }
            const startKey = toSerialDayKey(window.minDate || minDate);
            const dayNumber = dk - startKey + 1;

            taskDiv.textContent = task.tasktitle || "(no title)";
            let baseTooltip =
              `Skill: ${task.skill || ""}\n` +
              `Date: ${formatDisplayDateShort(
                dayKeyToDate(dk)
              )} (Day ${dayNumber})\n` +
              `${task.tasktitle || ""}\n` +
              `Remarks: ${task.remarks || ""}\n` +
              `Status: ${task.status || ""}\n` +
              `${diffText}`;

            taskDiv.title = baseTooltip + buildDependencyTooltip(task);

            taskDiv.dataset.taskId = task._id;
            if (task.remarks && task.remarks.trim() !== "") {
              const icon = document.createElement("span");
              icon.textContent = "‚ö†Ô∏è";
              icon.style.position = "absolute";
              icon.style.bottom = "2px";
              icon.style.right = "1px";
              icon.style.fontSize = "10px";
              taskDiv.appendChild(icon);
            }

            taskDiv.draggable = true;
            taskDiv.addEventListener("dragstart", onTaskDragStart);
            taskDiv.addEventListener("dragend", onTaskDragEnd); // Double-click on TASK: ALWAYS open Bulk Action Modal

            // Double-click on TASK: ALWAYS open Bulk Action Modal
            taskDiv.addEventListener("dblclick", (e) => {
              e.stopPropagation(); // Prevent triggering "Blank Row" click
              const thisTaskId = task._id;

              // 1. Ensure the task is selected
              if (!selectedTaskIds.includes(thisTaskId)) {
                if (!e.ctrlKey && !e.metaKey) {
                  clearSelection();
                }
                selectedTaskIds.push(thisTaskId);
                taskDiv.classList.add("task-selected");
              }

              // 2. Set the Anchor
              bulkActionAnchorTaskId = thisTaskId;

              // 3. Configure the Modal UI
              const count = selectedTaskIds.length;
              document.getElementById("bulk-action-title").textContent =
                count > 1
                  ? `Bulk Action for ${count} Milestone`
                  : "Milestone Action";

              // --- UPDATED: Set date to the TASK'S current start date ---
              // Priority: Revised Start -> Planned Start -> Today (fallback)
              const dateToUse = task.rev_sdate || task.sdate;
              const dateObj = parseDateField(dateToUse);

              if (dateObj) {
                bulkActionDate.value = dayKeyToISO(toSerialDayKey(dateObj));
              } else {
                // Fallback if task has no date
                bulkActionDate.value = dayKeyToISO(toSerialDayKey(new Date()));
              }
              // -------------------------------------------------------

              bulkActionRemarks.value = "";

              // Show "Edit Details" button ONLY if single task is selected
              bulkEditDetails.style.display = count === 1 ? "" : "none";

              bulkActionModal.style.display = "flex";
            });

            taskDiv.addEventListener("contextmenu", (ev) => {
              ev.preventDefault();
              if (selectedTaskIds.length > 1) {
                bulkClosingMode = true;
                remarksEditingTaskId = null;
                remarksTextarea.value = "";
                remarksEditor.style.left =
                  ev.clientX + window.scrollX + 6 + "px";
                remarksEditor.style.top =
                  ev.clientY + window.scrollY + 6 + "px";
                remarksEditor.style.display = "block";
                remarksTextarea.focus();
              } else {
                bulkClosingMode = false;
                openRemarksEditor(ev, task._id);
              }
            });

            td.appendChild(taskDiv);
          }
        });
      }

      // convert dayKey integer -> ISO string YYYY-MM-DD
      function dayKeyToISO(dayKey) {
        const dt = dayKeyToDate(Number(dayKey));
        const yyyy = dt.getUTCFullYear();
        const mm = String(dt.getUTCMonth() + 1).padStart(2, "0");
        const dd = String(dt.getUTCDate()).padStart(2, "0");
        return `${yyyy}-${mm}-${dd}`;
      }

      // ---------- Drag & Drop handlers ----------
      function onTaskDragStart(e) {
        const tid = e.target.dataset.taskId;
        if (!tid) return;

        const t = window.currentRows.find((r) => r._id === tid);
        if (t && (t.status || "").toLowerCase() === "closed") {
          e.preventDefault();
          return;
        }

        // If the dragged task is not in the selection, select only it
        if (!selectedTaskIds.includes(tid)) {
          document
            .querySelectorAll(".task-selected")
            .forEach((el) => el.classList.remove("task-selected"));
          selectedTaskIds = [tid];
          e.target.classList.add("task-selected");
        }

        e.dataTransfer.setData("text/plain", tid);
        e.dataTransfer.effectAllowed = "move";

        // Custom drag image
        try {
          const clone = e.target.cloneNode(true);
          clone.style.position = "absolute";
          clone.style.top = "-100px";
          clone.style.left = "-100px";
          clone.style.width = "220px";
          document.body.appendChild(clone);
          e.dataTransfer.setDragImage(clone, 10, 10);
          setTimeout(() => document.body.removeChild(clone), 0);
        } catch (err) {}
      }

      async function onTaskDragEnd(e) {
        // Remove highlights
        document
          .querySelectorAll("td.drop-target")
          .forEach((td) => td.classList.remove("drop-target"));

        tableContainer.style.cursor = "default";

        // üî• FORCE REBUILD AFTER DRAGGING & CASCADE
        setTimeout(() => {
          ensureTimelineRange(true); // recalc min/max dates
          applyWOfilterAndRender(); // rebuild table
        }, 250);
      }

      function attachDropHandlersToTd(td) {
        if (td._dropAttached) return;
        td._dropAttached = true;
        td.addEventListener("dragover", (ev) => {
          ev.preventDefault();
          td.classList.add("drop-target");
        });
        td.addEventListener("dragleave", (ev) => {
          td.classList.remove("drop-target");
        });
        td.addEventListener("drop", async (ev) => {
          ev.preventDefault();
          td.classList.remove("drop-target");

          const tid = ev.dataTransfer.getData("text/plain");
          if (!tid) return;
          const dayStr = td.dataset.day;
          if (!dayStr) return;

          const dayKey = Number(dayStr);
          const draggedTask = window.currentRows.find((r) => r._id === tid);
          if (!draggedTask) return; // --- üõë SKILL CHECK REMOVED --- // The original "bounce" check that compared // draggedTask.skill to dropSkill is now gone. // Get the date shift from the primary dragged task

          const revS = parseDateField(
            draggedTask.rev_sdate ?? draggedTask.sdate
          );
          const startKey = toSerialDayKey(
            revS || parseDateField(draggedTask.sdate)
          );
          const dayShift = dayKey - startKey; // Move all selected tasks

          for (const id of selectedTaskIds) {
            const task = window.currentRows.find((r) => r._id === id);
            if (!task) continue; // --- üõë SKILL CHECK REMOVED --- // The check inside the loop that skipped // tasks from other skills is also gone. // Calculate new dates based on the dayShift

            const revS = parseDateField(task.rev_sdate ?? task.sdate);
            const revE = parseDateField(task.rev_edate ?? task.edate);
            const startKeyTask = toSerialDayKey(
              revS || parseDateField(task.sdate)
            );
            const endKeyTask = toSerialDayKey(
              revE || parseDateField(task.edate)
            );
            const duration = endKeyTask - startKeyTask;

            const newRevS_ISO = dayKeyToISO(startKeyTask + dayShift);
            const newRevE_ISO = dayKeyToISO(startKeyTask + dayShift + duration); // --- üõë SKILL UPDATE REMOVED --- // We no longer change the task's skill. // We only update its dates.

            await updateTask(task._id, {
              rev_sdate: newRevS_ISO,
              rev_edate: newRevE_ISO, // 'skill' property is no longer included
            });
            cascadeVisited.clear();
            await cascadeDependents(task._id, dayShift);
          } // üîπ Auto reset selection after bulk move
          clearSelection();
        });
        // ‚úÖ NEW: double click empty cell to add a task
        td.addEventListener("dblclick", async () => {
          if (td.querySelector(".task-block")) return; // already has a task
          const dayKey = Number(td.dataset.day);
          if (!dayKey) return;

          const skill = td.closest("tr")?.dataset?.skill || "Unassigned";

          // --- Generate unique task ID based on date + time ---
          const now = new Date();
          const pad = (n) => String(n).padStart(2, "0");
          const taskId =
            now.getFullYear().toString() +
            pad(now.getMonth() + 1) +
            pad(now.getDate()) +
            "-" +
            pad(now.getHours()) +
            pad(now.getMinutes()) +
            pad(now.getSeconds()) +
            "-" +
            now.getMilliseconds();
          // ‚úÖ get acreg from the table heading data we saved
          const acregFromHeading =
            window.currentAcregs && window.currentAcregs.length
              ? window.currentAcregs[0]
              : "";
          // --- Pre-fill modal form ---
          modalEditingId = null; // new task
          f.taskid.value = taskId;
          f.skill.value = skill;
          f.sdate.value = dayKeyToISO(dayKey);
          f.edate.value = dayKeyToISO(dayKey);
          f.rev_sdate.value = dayKeyToISO(dayKey);
          f.rev_edate.value = dayKeyToISO(dayKey);
          f.tasktitle.value = "";
          f.acreg.value = acregFromHeading;
          f.remarks.value = "Newly Added";
          f.statusOpen.checked = true;
          f.workorder.value = woFilterValue || "";

          modalTitle.textContent = "Add Milestone";
          modal.style.display = "flex";
        });
      }

      let renderPending = false;

      function scheduleRender() {
        if (renderPending) return;
        renderPending = true;
        requestAnimationFrame(() => {
          ensureTimelineRange(true);
          applyWOfilterAndRender();
          renderPending = false;
        });
      }

      // ---------- Inline editor (title) ----------
      function openInlineEditor(el, task) {
        // create small input overlay
        const input = document.createElement("input");
        input.type = "text";
        input.value = task.tasktitle || "";
        input.className = "inline-edit";
        input.style.minWidth = "160px";
        el.style.display = "inline-block";
        el.innerHTML = "";
        el.appendChild(input);
        input.focus();
        input.select();

        const commit = async () => {
          const val = input.value.trim();
          el.textContent = val || "(no title)";
          await updateTask(task._id, { tasktitle: val });
        };
        input.addEventListener("blur", commit);
        input.addEventListener("keydown", async (e) => {
          if (e.key === "Enter") {
            input.blur();
          }
          if (e.key === "Escape") {
            el.textContent = task.tasktitle || "(no title)";
          }
        });
      }

      // ---------- Remarks editor ----------
      const remarksEditor = document.getElementById("remarks-editor");
      const remarksTextarea = document.getElementById("remarks-text");
      let remarksEditingTaskId = null;

      function openRemarksEditor(mouseEvent, taskId) {
        const task = window.currentRows.find((r) => r._id === taskId);
        if (!task) return;
        remarksEditingTaskId = taskId;
        remarksTextarea.value = task.remarks || "";
        // position editor near mouse
        const x = mouseEvent.clientX + window.scrollX;
        const y = mouseEvent.clientY + window.scrollY;
        remarksEditor.style.left = x + 6 + "px";
        remarksEditor.style.top = y + 6 + "px";
        remarksEditor.style.display = "block";
        remarksTextarea.focus();

        // show/hide close button
        const closeBtn = document.getElementById("remarks-close-task");
        if ((task.status || "").toLowerCase() === "closed") {
          closeBtn.style.display = "none";
        } else closeBtn.style.display = "";
      }

      document
        .getElementById("remarks-save")
        .addEventListener("click", async () => {
          const remarksText = remarksTextarea.value.trim();

          if (selectedTaskIds.length > 1) {
            // Multi-select: append to all selected tasks
            for (const id of selectedTaskIds) {
              const task = window.currentRows.find((r) => r._id === id);
              if (!task) continue;

              const existingRemarks = task.remarks?.trim() || "";
              const newRemarks = existingRemarks
                ? `${existingRemarks}\n${remarksText}` // append on new line
                : remarksText;

              await updateTask(id, { remarks: newRemarks });
            }
          } else if (remarksEditingTaskId) {
            // Single task mode (replace)
            await updateTask(remarksEditingTaskId, { remarks: remarksText });
          }

          // Close the editor and clear selection
          remarksEditor.style.display = "none";
          remarksEditingTaskId = null;
          selectedTaskIds = [];
          document
            .querySelectorAll(".task-selected")
            .forEach((el) => el.classList.remove("task-selected"));
        });

      document
        .getElementById("remarks-cancel")
        .addEventListener("click", () => {
          remarksEditor.style.display = "none";
          remarksEditingTaskId = null;
        });
      document
        .getElementById("remarks-close-task")
        .addEventListener("click", async () => {
          const remarksText = remarksTextarea.value.trim();
          const yesterday = new Date();
          yesterday.setDate(yesterday.getDate() - 1);
          const todayKey = toSerialDayKey(yesterday);

          if (bulkClosingMode) {
            for (const id of selectedTaskIds) {
              const task = window.currentRows.find((r) => r._id === id);
              if (!task) continue;

              const revS = parseDateField(task.rev_sdate ?? task.sdate);

              // ‚õî NEW CHECK: Prevent closing a child while parent is open
              if (task.dependencies && task.dependencies.length > 0) {
                const parents = task.dependencies
                  .map((pid) => window.currentRows.find((r) => r._id === pid))
                  .filter(Boolean);

                const openParents = parents.filter(
                  (p) => !p.status || p.status.toLowerCase() !== "closed"
                );

                if (openParents.length > 0) {
                  const names = openParents
                    .map((p) => p.tasktitle || p._id)
                    .join(", ");

                  alert(
                    `‚ùå Cannot close "${task.tasktitle}".\n` +
                      `It has parent tasks still open:\n${names}`
                  );
                  // Close editor
                  remarksEditor.style.display = "none";
                  remarksEditingTaskId = null;
                  return; // STOP CLOSING
                }
              }

              const revE = parseDateField(task.rev_edate ?? task.edate);
              const startKey = revS
                ? toSerialDayKey(revS)
                : toSerialDayKey(parseDateField(task.sdate));
              const duration = revE ? toSerialDayKey(revE) - startKey : 0;

              await updateTask(task._id, {
                status: "Closed",
                remarks: remarksText,
              });
            }

            // Clear selection after closing
            document
              .querySelectorAll(".task-selected")
              .forEach((el) => el.classList.remove("task-selected"));
            selectedTaskIds = [];
            bulkClosingMode = false;
          } else if (remarksEditingTaskId) {
            const task = window.currentRows.find(
              (r) => r._id === remarksEditingTaskId
            );
            if (!task) return;

            // ‚õî NEW CHECK: Prevent closing a child while parent is open
            if (task.dependencies && task.dependencies.length > 0) {
              const parents = task.dependencies
                .map((pid) => window.currentRows.find((r) => r._id === pid))
                .filter(Boolean);

              const openParents = parents.filter(
                (p) => !p.status || p.status.toLowerCase() !== "closed"
              );

              if (openParents.length > 0) {
                const names = openParents
                  .map((p) => p.tasktitle || p._id)
                  .join(", ");

                alert(
                  `‚ùå Cannot close "${task.tasktitle}".\n` +
                    `It has parent tasks still open:\n${names}`
                );
                // Close editor
                remarksEditor.style.display = "none";
                remarksEditingTaskId = null;
                return; // STOP CLOSING ‚ùó
              }
            }

            const revS = parseDateField(task.rev_sdate ?? task.sdate);
            const revE = parseDateField(task.rev_edate ?? task.edate);
            const startKey = revS
              ? toSerialDayKey(revS)
              : toSerialDayKey(parseDateField(task.sdate));
            const duration = revE ? toSerialDayKey(revE) - startKey : 0;

            await updateTask(task._id, {
              status: "Closed",
              remarks: remarksText,
            });
          }

          // Close editor
          remarksEditor.style.display = "none";
          remarksEditingTaskId = null;
        });

      ///new***********************
      let selectedTaskIds = [];
      let bulkClosingMode = false;
      let bulkActionAnchorTaskId = null;

      document.addEventListener("click", (e) => {
        if (e.target.closest(".task-block")) return;
        if (e.target.closest("#remarks-editor")) return;
        if (e.target.closest("#bulk-action-modal")) return;
        if (e.target.closest("#task-modal")) return;
        clearSelection();
      });

      document.addEventListener("click", (e) => {
        const taskDiv = e.target.closest(".task-block");
        if (!taskDiv) return;
        if (!(e.ctrlKey || e.metaKey)) return;
        const tid = taskDiv.dataset.taskId;

        // Prevent selecting closed tasks
        const task = window.currentRows.find((r) => r._id === tid);
        if (task && (task.status || "").toLowerCase() === "closed") {
          return; // Ignore clicks on closed tasks
        }

        if (e.ctrlKey) {
          // Toggle selection
          if (selectedTaskIds.includes(tid)) {
            selectedTaskIds = selectedTaskIds.filter((id) => id !== tid);
            taskDiv.classList.remove("task-selected");
          } else {
            selectedTaskIds.push(tid);
            taskDiv.classList.add("task-selected");
          }
        } else {
          // Clear selection and select only this task
          document
            .querySelectorAll(".task-selected")
            .forEach((el) => el.classList.remove("task-selected"));
          selectedTaskIds = [tid];
          taskDiv.classList.add("task-selected");
        }
      });

      function clearSelection() {
        document
          .querySelectorAll(".task-selected")
          .forEach((el) => el.classList.remove("task-selected"));
        selectedTaskIds = [];
      }

      // Clear selection when clicking anywhere that's NOT a task, remarks, or bulk-close modal
      document.addEventListener("click", (e) => {
        if (
          e.target.closest(".task-block") ||
          e.target.closest("#remarks-editor") ||
          e.target.closest("#bulk-action-modal")
        )
          // <-- ADD THIS LINE
          return;
        clearSelection();
      });

      // hide editor when clicking outside
      document.addEventListener("click", (ev) => {
        if (!remarksEditor.contains(ev.target)) {
          remarksEditor.style.display = "none";
          remarksEditingTaskId = null;
        }
      });

      // ---------- Modal edit / add ----------
      const modal = document.getElementById("task-modal");
      const modalTitle = document.getElementById("modal-title");
      const f = {
        taskid: document.getElementById("f-taskid"),
        skill: document.getElementById("f-skill"),
        sdate: document.getElementById("f-sdate"),
        edate: document.getElementById("f-edate"),
        rev_sdate: document.getElementById("f-rev_sdate"),
        rev_edate: document.getElementById("f-rev_edate"),
        tasktitle: document.getElementById("f-tasktitle"),
        acreg: document.getElementById("f-acreg"),
        remarks: document.getElementById("f-remarks"),
        statusOpen: document.getElementById("f-status-open"),
        statusClosed: document.getElementById("f-status-closed"),
        workorder: document.getElementById("f-workorder"),
      };
      let modalEditingId = null;
      // Get the new Bulk Action Modal elements
      const bulkActionModal = document.getElementById("bulk-action-modal");
      const bulkActionDate = document.getElementById("bulk-action-date");
      const bulkActionRemarks = document.getElementById("bulk-action-remarks");
      const bulkActionCancel = document.getElementById("bulk-action-cancel");
      const bulkEditDetails = document.getElementById("bulk-edit-details");
      const bulkCloseConfirm = document.getElementById("bulk-close-confirm");
      const bulkReplanConfirm = document.getElementById("bulk-replan-confirm");
      const bulkNewPlanConfirm = document.getElementById(
        "bulk-new-plan-confirm"
      );
      // document.getElementById('add-task-btn').addEventListener('click', () => openTaskModal(null));
      document
        .getElementById("cancel-modal")
        .addEventListener("click", closeTaskModal);
      document
        .getElementById("delete-task-btn")
        .addEventListener("click", async () => {
          if (!modalEditingId) {
            alert("No milestone selected to delete");
            return;
          }
          if (!confirm("Delete this milestone?")) return;
          await deleteTask(modalEditingId);
          closeTaskModal();
        });
      document
        .getElementById("save-modal")
        .addEventListener("click", async () => {
          const payload = {
            taskid: f.taskid.value || undefined,
            skill: f.skill.value || undefined,
            sdate: f.sdate.value || undefined,
            edate: f.edate.value || undefined,
            rev_sdate: f.rev_sdate.value || undefined,
            rev_edate: f.rev_edate.value || undefined,
            tasktitle: f.tasktitle.value || undefined,
            acreg: f.acreg.value || undefined,
            remarks: f.remarks.value,
            status: f.statusClosed.checked ? "Closed" : "open",
            workorder: f.workorder.value || undefined,
          };

          // ‚õî MUST RUN BEFORE any updateTask()
          // ---------------------------------------
          if (modalEditingId && payload.status === "Closed") {
            const task = window.currentRows.find(
              (t) => t._id === modalEditingId
            );

            if (task && task.dependencies && task.dependencies.length > 0) {
              const parents = task.dependencies
                .map((pid) => window.currentRows.find((t) => t._id === pid))
                .filter(Boolean);

              const openParents = parents.filter(
                (p) => !p.status || p.status.toLowerCase() !== "closed"
              );

              if (openParents.length > 0) {
                const names = openParents
                  .map((p) => p.tasktitle || p._id)
                  .join(", ");

                alert(
                  `‚ùå Cannot close "${task.tasktitle}".\n` +
                    `It has parent tasks still OPEN:\n${names}`
                );
                closeTaskModal();
                return; // ‚õî STOP ‚Äî DO NOT SAVE ANY UPDATE
              }
            }
          }
          // ---------------------------------------

          // ‚úîÔ∏è Only update after dependency check passes
          if (modalEditingId) {
            await updateTask(modalEditingId, payload);
          } else {
            if (payload.taskid) {
              payload._id = payload.taskid;
              await createTask(payload);
            } else {
              await createTask(payload);
            }
          }

          closeTaskModal();
        });

      // --- New Bulk Action Modal Listeners ---

      bulkActionCancel.addEventListener("click", () => {
        bulkActionModal.style.display = "none";
        bulkActionAnchorTaskId = null;
      });

      // Allow switching from Action Modal -> Full Edit Modal
      bulkEditDetails.addEventListener("click", () => {
        // Close the action modal
        bulkActionModal.style.display = "none";

        // Find the task (it's stored in the anchor ID)
        const task = window.currentRows.find(
          (r) => r._id === bulkActionAnchorTaskId
        );

        // Clear selection logic
        clearSelection();
        bulkActionAnchorTaskId = null;

        // Open the full editor
        if (task) {
          openTaskModal(task);
        }
      });

      // "Confirm Close" button logic (this is your existing logic)
      bulkCloseConfirm.addEventListener("click", async () => {
        const dateStr = bulkActionDate.value;
        const closingRemark = bulkActionRemarks.value;

        if (!dateStr) {
          alert("Please select an Action Date.");
          return;
        }

        const closeDate = parseDateField(dateStr);
        if (!closeDate || isNaN(closeDate.getTime())) {
          alert("Invalid date format.");
          return;
        }
        const closeDateKey = toSerialDayKey(closeDate);

        await closeTasks(selectedTaskIds, closingRemark, closeDateKey);

        bulkActionModal.style.display = "none";
        clearSelection();
        bulkActionAnchorTaskId = null;
      });

      /**
       * Performs the relative move for "New Plan" and "Replan".
       * isNewPlan = true: Resets history (orig_sdate = null)
       * isNewPlan = false: Creates history (orig_sdate = sdate)
       */
      async function performRelativeMove(isNewPlan = false) {
        const dateStr = bulkActionDate.value;
        const remarks = bulkActionRemarks.value;

        // --- 1. Get New Start Date (from modal) ---
        if (!dateStr) {
          alert("Please select an Action Date.");
          return;
        }
        const newStartDate = parseDateField(dateStr);
        if (!newStartDate || isNaN(newStartDate.getTime())) {
          alert("Invalid date format.");
          return;
        }
        const newStartDateKey = toSerialDayKey(newStartDate);

        // --- 2. Find the Anchor Task and Calculate the Date Shift ---
        const anchorTask = window.currentRows.find(
          (r) => r._id === bulkActionAnchorTaskId
        );
        if (!anchorTask) {
          alert(
            "Error: Anchor milestone not found. Cannot perform relative replan."
          );
          return;
        }
        const anchorOrigSDate = parseDateField(anchorTask.sdate);
        if (!anchorOrigSDate) {
          alert(
            "Error: Anchor milestone is missing its original start date (sdate)."
          );
          return;
        }
        const anchorOrigSKey = toSerialDayKey(anchorOrigSDate);
        const dateShift = newStartDateKey - anchorOrigSKey;

        // --- 3. Loop and Replan ALL Selected Tasks ---
        for (const id of selectedTaskIds) {
          const task = window.currentRows.find((r) => r._id === id);
          if (!task) continue;

          const sdate = parseDateField(task.sdate);
          const edate = parseDateField(task.edate);
          let duration = 0;

          if (sdate && edate) {
            const taskOrigSKey = toSerialDayKey(sdate);
            const taskOrigEKey = toSerialDayKey(edate);
            duration = taskOrigEKey - taskOrigSKey;
            if (duration < 0) duration = 0;

            const newSKey = taskOrigSKey + dateShift;
            const newEKey = newSKey + duration;
            const newS_ISO = dayKeyToISO(newSKey);
            const newE_ISO = dayKeyToISO(newEKey);

            // --- Build the Update Payload ---
            const updatePayload = {
              sdate: newS_ISO,
              edate: newE_ISO,
              rev_sdate: newS_ISO,
              rev_edate: newE_ISO,
              remarks: remarks,
              status: "open",
            };

            // THIS IS THE KEY LOGIC
            if (isNewPlan) {
              // "New Plan" button: Erase history
              updatePayload.orig_sdate = null;
            } else {
              // "Replan" button: Create history if it doesn't exist
              if (!task.orig_sdate && task.sdate) {
                updatePayload.orig_sdate = task.sdate;
              }
            }
            // --- End Payload ---

            await updateTask(id, updatePayload);
          } else {
            console.warn(`Skipping task ${task._id}, missing sdate or edate.`);
          }
        }

        bulkActionModal.style.display = "none";
        clearSelection();
        bulkActionAnchorTaskId = null; // Clear the anchor
      }

      // "Confirm Replan" button (blue) now calls the helper
      bulkReplanConfirm.addEventListener("click", () => {
        performRelativeMove(false); // false = NOT a new plan, so keep history
      });

      // "New Plan" button (yellow) now calls the helper
      bulkNewPlanConfirm.addEventListener("click", () => {
        performRelativeMove(true); // true = IS a new plan, so erase history
      });
      // ---------- VVV ADD THIS ENTIRE FUNCTION VVV ----------

      /**
       * Adds a list of tasks to the CURRENTLY selected Work Order.
       * @param {Array} newTasks - Array of objects: { title, skill, sdate, edate }
       */
      async function addTasksToCurrentWO(newTasks) {
        // 1. Get the globally selected Work Order
        const currentWO = woFilterValue; // This variable exists in your code

        // 2. Validation: Stop if no WO is selected
        if (!currentWO || currentWO === "") {
          alert(
            "Error: No Work Order selected. Please select a WO from the dropdown first."
          );
          return;
        }

        // 3. Get the Aircraft Reg (AC Reg) automatically
        const currentAC =
          window.currentAcregs && window.currentAcregs.length > 0
            ? window.currentAcregs[0]
            : "";

        console.log(
          `Adding ${newTasks.length} tasks to WO: ${currentWO} (AC: ${currentAC})...`
        );

        // 4. Loop and Create
        for (const task of newTasks) {
          try {
            // Construct the full payload
            const payload = {
              tasktitle: task.title || "Untitled",
              skill: task.skill || "GEN", // Default skill if missing

              // Dates (ensure they are YYYY-MM-DD strings)
              sdate: task.sdate,
              edate: task.edate,
              rev_sdate: task.sdate, // Default revised to same as plan
              rev_edate: task.edate,

              // The Automatic Parts
              workorder: currentWO,
              acreg: currentAC,
              status: "open",
            };

            await createTask(payload); // Assumes createTask function exists
          } catch (err) {
            console.error(`Failed to add task "${task.title}":`, err);
          }
        }

        console.log("Batch add complete.");
      }
      // This array will hold the tasks before we save them
      let taskQueue = [];
      let userHasManuallySetEndDate = false;
      // Get all the new elements
      const batchAddModal = document.getElementById("batch-add-modal");
      const openBatchAddBtn = document.getElementById("open-batch-add-btn");
      const batchAddCancel = document.getElementById("batch-add-cancel");
      const addToQueueBtn = document.getElementById("add-to-queue-btn");
      const batchSaveAllBtn = document.getElementById("batch-save-all-btn");
      const taskQueueList = document.getElementById("task-queue-list");
      const queueCountEl = document.getElementById("queue-count");

      // Form Inputs
      const b = {
        title: document.getElementById("b-tasktitle"),
        skill: document.getElementById("b-skill"),
        sdate: document.getElementById("b-sdate"),
        edate: document.getElementById("b-edate"),
      };

      // This listener links the start and end dates
      // --- Wire up the date linking logic ---

      // 1. When Start Date changes:
      b.sdate.addEventListener("change", () => {
        // If user hasn't manually set an end date, link them.
        if (!userHasManuallySetEndDate) {
          b.edate.value = b.sdate.value;
        } else {
          // If user HAS set a date, just make sure it's not invalid
          if (b.edate.value < b.sdate.value) {
            b.edate.value = b.sdate.value;
          }
        }
      });

      // 2. When End Date changes, set the flag
      b.edate.addEventListener("change", () => {
        // As soon as the user changes the end date, we set the flag.
        // We add a small check to not set the flag if the dates are the same.
        if (b.edate.value !== b.sdate.value) {
          userHasManuallySetEndDate = true;
        }
      });

      // --- Helper function to re-draw the queue list ---
      function renderTaskQueue() {
        taskQueueList.innerHTML = "";
        queueCountEl.textContent = taskQueue.length;

        if (taskQueue.length === 0) {
          taskQueueList.innerHTML =
            '<p style="color: #888; font-size: 13px;">Queue is empty.</p>';
          return;
        }

        taskQueue.forEach((task, index) => {
          const item = document.createElement("div");
          item.className = "queue-item";
          item.style.display = "flex";
          item.style.justifyContent = "space-between";
          item.style.alignItems = "center";
          item.style.padding = "6px 8px";
          item.style.border = "1px solid #ccc";
          item.style.borderRadius = "6px";
          item.style.marginBottom = "6px";
          item.style.background = "#f7f7f7";

          item.innerHTML = `
              <div>
                <strong>${task.title}</strong><br>
                <span style="font-size:12px;">
                  Skill: ${task.skill} |
                  Start: ${task.sdate} |
                  End: ${task.edate}
                </span>
              </div>

              <div style="display:flex; gap:6px;">
                <button class="queue-edit-btn" data-index="${index}"
                  style="background:#3b82f6; color:#fff; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">
                  Edit
                </button>

                <button class="queue-remove-btn" data-index="${index}"
                  style="background:#dc2626; color:#fff; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">
                  Remove
                </button>
              </div>
            `;

          taskQueueList.appendChild(item);
        });

        // Attach edit/remove events
        document.querySelectorAll(".queue-remove-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            const i = Number(btn.dataset.index);
            taskQueue.splice(i, 1);
            renderTaskQueue();
          });
        });

        document.querySelectorAll(".queue-edit-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            const i = Number(btn.dataset.index);
            loadTaskIntoForm(i);
          });
        });
      }
      function loadTaskIntoForm(index) {
        const task = taskQueue[index];
        if (!task) return;

        editingQueueIndex = index;

        b.title.value = task.title;
        b.skill.value = task.skill;
        b.sdate.value = task.sdate;
        b.edate.value = task.edate;

        addToQueueBtn.textContent = "Update Task";
        addToQueueBtn.style.background = "#f59e0b";
      }
      //addToQueueBtn.onclick = addTaskToQueueDefault;
      function resetBatchForm() {
        b.title.value = "";
        b.skill.value = "";
        const today = dayKeyToISO(toSerialDayKey(new Date()));
        b.sdate.value = today;
        b.edate.value = today;
        userHasManuallySetEndDate = false;

        editingQueueIndex = null;
      }
      function addTaskToQueueDefault() {
        const task = {
          title: b.title.value.trim(),
          skill: b.skill.value.trim(),
          sdate: b.sdate.value,
          edate: b.edate.value,
        };

        if (!task.title || !task.skill || !task.sdate || !task.edate) {
          alert("Please fill in Title, Skill, Start Date, and End Date.");
          return;
        }

        taskQueue.push(task);
        renderTaskQueue();
        resetBatchForm();
      }

      // --- Wire up the buttons ---

      // 1. Open the batch modal
      openBatchAddBtn.addEventListener("click", () => {
        // Check if a WO is selected
        if (!woFilterValue || woFilterValue === "") {
          alert("Please select a Work Order from the dropdown first.");
          return;
        }
        userHasManuallySetEndDate = false;
        taskQueue = []; // Clear the queue
        renderTaskQueue(); // Re-draw the empty list

        // Set default date to today
        const todayISO = dayKeyToISO(toSerialDayKey(new Date()));
        b.sdate.value = todayISO;
        b.edate.value = todayISO;
        b.title.value = "";
        b.skill.value = "";

        batchAddModal.style.display = "flex";
        b.title.focus();
      });

      // 2. Add a single task to the queue
      addToQueueBtn.addEventListener("click", () => {
        const title = b.title.value.trim();
        const skill = b.skill.value;
        const sdate = b.sdate.value;
        const edate = b.edate.value;

        // VALIDATION ‚Äî this was failing before because fields were undefined
        if (!title || !skill || !sdate || !edate) {
          alert("Please fill in Title, Skill, Start Date, and End Date.");
          return;
        }

        if (editingQueueIndex === null) {
          // NORMAL ADD MODE
          taskQueue.push({ title, skill, sdate, edate });
        } else {
          // EDIT MODE
          taskQueue[editingQueueIndex] = { title, skill, sdate, edate };
          editingQueueIndex = null;

          // Restore button
          addToQueueBtn.textContent = "Add to Queue";
          addToQueueBtn.style.background = "";
        }

        renderTaskQueue();
      });

      // 3. Save the entire queue to Firestore
      batchSaveAllBtn.addEventListener("click", async () => {
        if (isBatchSaving) return; // ‚õî Prevent duplicate clicks immediately
        if (taskQueue.length === 0) {
          alert("Queue is empty. Nothing to save.");
          return;
        }

        isBatchSaving = true; // üîí Lock
        batchSaveAllBtn.disabled = true; // üîí Disable button
        batchSaveAllBtn.textContent = "Saving..."; // UX feedback

        try {
          await addTasksToCurrentWO(taskQueue);

          // Close and reset
          batchAddModal.style.display = "none";
          taskQueue = [];
        } catch (err) {
          console.error("Batch save failed:", err);
          alert("Error saving tasks. Please try again.");
        }

        // üîì Unlock and restore UI
        isBatchSaving = false;
        batchSaveAllBtn.disabled = false;
        batchSaveAllBtn.textContent = "Save All";
      });

      // 4. Cancel and close the modal
      batchAddCancel.addEventListener("click", () => {
        if (
          taskQueue.length > 0 &&
          !confirm(
            "You have milestone in the queue. Are you sure you want to cancel?"
          )
        ) {
          return; // Do not close
        }
        batchAddModal.style.display = "none";
        taskQueue = [];
      });

      function openTaskModal(task) {
        modalEditingId = null;
        modalTitle.textContent = task ? "Edit Milestone" : "Add Milestone";
        // reset
        // Reset inputs (but skip radio buttons so we don't wipe their values)
        Object.values(f).forEach((inp) => {
          if (inp && inp.type !== "radio") inp.value = "";
        });
        document.getElementById("delete-task-btn").style.display = task
          ? ""
          : "none";
        if (task) {
          modalEditingId = task._id;
          f.taskid.value = task.taskid || task._id;
          f.skill.value = task.skill || "";
          f.sdate.value =
            task.sdate || task._sdate
              ? task.sdate || task._sdate.toISOString().slice(0, 10)
              : "";
          f.edate.value =
            task.edate || task._edate
              ? task.edate || task._edate.toISOString().slice(0, 10)
              : "";
          f.rev_sdate.value =
            task.rev_sdate || task._rev_sdate
              ? task.rev_sdate || task._rev_sdate.toISOString().slice(0, 10)
              : "";
          f.rev_edate.value =
            task.rev_edate || task._rev_edate
              ? task.rev_edate || task._rev_edate.toISOString().slice(0, 10)
              : "";
          f.tasktitle.value = task.tasktitle || "";
          f.acreg.value = task.acreg || "";
          f.remarks.value = task.remarks || "";
          // CHANGED: Set the correct radio button
          const currentStatus = (task.status || "open").toLowerCase();
          if (currentStatus === "closed") {
            f.statusClosed.checked = true;
          } else {
            f.statusOpen.checked = true;
          }
          f.workorder.value = task.workorder || "";
        }
        // Ensure Open is default for new tasks
        if (!task) f.statusOpen.checked = true;
        modal.style.display = "flex";
      }
      function closeTaskModal() {
        modal.style.display = "none";
        modalEditingId = null;
      }

      const tableContainer = document.getElementById("matrix-container");

      let isPanning = false;
      let startX, startY, scrollLeft, scrollTop;

      tableContainer.addEventListener("mousedown", (e) => {
        if (e.button !== 0) return; // left click only
        isPanning = true;
        tableContainer.style.cursor = "grabbing";
        startX = e.pageX - tableContainer.offsetLeft;
        startY = e.pageY - tableContainer.offsetTop;
        scrollLeft = tableContainer.scrollLeft;
        scrollTop = tableContainer.scrollTop;
      });

      tableContainer.addEventListener("mousemove", (e) => {
        // Only pan if left button is still held
        if (!isPanning || e.buttons !== 1) return;

        e.preventDefault();
        const x = e.pageX - tableContainer.offsetLeft;
        const y = e.pageY - tableContainer.offsetTop;
        const walkX = x - startX;
        const walkY = y - startY;
        tableContainer.scrollLeft = scrollLeft - walkX;
        tableContainer.scrollTop = scrollTop - walkY;
      });

      // Stop on mouseup anywhere
      window.addEventListener("mouseup", () => {
        isPanning = false;
        tableContainer.style.cursor = "default";
      });
      document.addEventListener("keydown", (e) => {
        if (e.ctrlKey && (e.key === "d" || e.key === "D")) {
          e.preventDefault();
          createDependencyFromSelection();
        }
      });
      async function createDependencyFromSelection() {
        if (selectedTaskIds.length !== 2) {
          alert("Select exactly two tasks.");
          return;
        }

        const tasks = selectedTaskIds
          .map((id) => window.currentRows.find((t) => t._id === id))
          .filter(Boolean);

        const A = tasks[0];
        const B = tasks[1];

        const startA = parseDateField(A.rev_sdate || A.sdate);
        const startB = parseDateField(B.rev_sdate || B.sdate);

        let parent, child;

        if (startA <= startB) {
          parent = A;
          child = B;
        } else {
          parent = B;
          child = A;
        }

        // ‚≠ê 1. Detect circular loops
        if (doesCreateCycle(parent._id, child._id)) {
          alert(
            "‚ùå Cannot create dependency: This will produce a circular dependency loop."
          );
          return;
        }

        // 2. Add dependency
        const deps = Array.isArray(child.dependencies)
          ? [...child.dependencies]
          : [];
        if (!deps.includes(parent._id)) deps.push(parent._id);

        await updateTask(child._id, { dependencies: deps });

        alert(
          `Dependency created:\n"${child.tasktitle}" now depends on "${parent.tasktitle}".`
        );

        clearSelection();
      }

      function doesCreateCycle(parentId, childId) {
        const visited = new Set();

        function dfs(taskId) {
          if (taskId === parentId) return true; // cycle found
          if (visited.has(taskId)) return false;

          visited.add(taskId);

          const t = window.currentRows.find((r) => r._id === taskId);
          if (!t || !Array.isArray(t.dependencies)) return false;

          return t.dependencies.some((dep) => dfs(dep));
        }

        return dfs(childId);
      }

      function ensureTimelineRange(forceRecalculate = false) {
        // If already initialized and not forced, keep existing
        if (!forceRecalculate && window.minDate && window.maxDate) {
          return {
            minKey: toSerialDayKey(window.minDate),
            maxKey: toSerialDayKey(window.maxDate),
          };
        }

        // If we reach here, we MUST calculate min/max safely
        const validTasks = window.currentRows
          ? window.currentRows.filter((t) => t.sdate || t.rev_sdate)
          : [];

        if (validTasks.length === 0) {
          console.warn("‚ö† Timeline cannot initialize ‚Äî no tasks available yet");
          return { minKey: 0, maxKey: 0 };
        }

        const startKeys = validTasks
          .map((t) => parseDateField(t.rev_sdate || t.sdate))
          .filter(Boolean)
          .map(toSerialDayKey);

        const endKeys = validTasks
          .map((t) => parseDateField(t.rev_edate || t.edate))
          .filter(Boolean)
          .map(toSerialDayKey);

        const minKey = Math.min(...startKeys);
        const maxKey = Math.max(...endKeys);

        window.minDate = dayKeyToDate(minKey);
        window.maxDate = dayKeyToDate(maxKey);

        return { minKey, maxKey };
      }

      let cascadeRenderPending = false;

      const cascadeVisited = new Set();

      async function cascadeDependents(parentId, dayShift) {
        if (dayShift === 0) return;

        if (cascadeVisited.has(parentId)) return; // ‚≠ê stop recursion loop
        cascadeVisited.add(parentId);

        const parent = window.currentRows.find((t) => t._id === parentId);
        if (!parent) return;

        const { minKey, maxKey } = ensureTimelineRange();

        const children = window.currentRows.filter(
          (t) =>
            Array.isArray(t.dependencies) && t.dependencies.includes(parentId)
        );

        for (const child of children) {
          const revS = parseDateField(child.rev_sdate || child.sdate);
          const revE = parseDateField(child.rev_edate || child.edate);
          if (!revS || !revE) continue;

          const startKey = toSerialDayKey(revS);
          const endKey = toSerialDayKey(revE);
          const duration = endKey - startKey;

          let newS = startKey + dayShift;
          let newE = newS + duration;

          // Clamp left boundary
          if (newS < minKey) {
            newS = minKey;
            newE = newS + duration;
          }
          // Clamp right boundary
          if (newE > maxKey) {
            newE = maxKey;
            newS = newE - duration;
          }

          await updateTask(child._id, {
            rev_sdate: dayKeyToISO(newS),
            rev_edate: dayKeyToISO(newE),
          });

          await cascadeDependents(child._id, dayShift);
        }

        // After ALL cascading is finished ‚Üí trigger a single rebuild
        if (!cascadeRenderPending) {
          cascadeRenderPending = true;

          setTimeout(() => {
            cascadeRenderPending = false;
            ensureTimelineRange(true); // recalc min/max BEFORE rendering
            applyWOfilterAndRender(); // redraw the table completely
          }, 150); // slight delay groups multiple updates together ‚úî
        }
      }

      document.addEventListener("keydown", (e) => {
        if (e.ctrlKey && (e.key === "x" || e.key === "X")) {
          e.preventDefault();
          removeDependencyFromSelection();
        }
      });
      async function removeDependencyFromSelection() {
        if (selectedTaskIds.length !== 2) {
          alert(
            "Please select EXACTLY two tasks, then press CTRL + E to remove dependency."
          );
          return;
        }

        // Get the tasks
        const tasks = selectedTaskIds
          .map((id) => window.currentRows.find((t) => t._id === id))
          .filter(Boolean);

        if (tasks.length !== 2) return;

        const t1 = tasks[0];
        const t2 = tasks[1];

        // Case 1: t2 depends on t1
        if (
          Array.isArray(t2.dependencies) &&
          t2.dependencies.includes(t1._id)
        ) {
          const updatedDeps = t2.dependencies.filter((dep) => dep !== t1._id);
          await updateTask(t2._id, { dependencies: updatedDeps });
          alert(
            `Dependency removed:\n"${t2.tasktitle}" no longer depends on "${t1.tasktitle}".`
          );
          clearSelection();
          return;
        }

        // Case 2: t1 depends on t2
        if (
          Array.isArray(t1.dependencies) &&
          t1.dependencies.includes(t2._id)
        ) {
          const updatedDeps = t1.dependencies.filter((dep) => dep !== t2._id);
          await updateTask(t1._id, { dependencies: updatedDeps });
          alert(
            `Dependency removed:\n"${t1.tasktitle}" no longer depends on "${t2.tasktitle}".`
          );
          clearSelection();
          return;
        }

        // No dependency found
        alert("These two tasks do NOT have a dependency.");
        clearSelection();
      }
      function buildDependencyTooltip(task) {
        if (!task) return "";

        const tasks = window.currentRows;

        // ---- PARENTS ----
        let parentLines = "";
        if (Array.isArray(task.dependencies) && task.dependencies.length > 0) {
          parentLines = task.dependencies
            .map((pid) => {
              const t = tasks.find((x) => x._id === pid);
              return t ? `‚Ä¢ ${t.tasktitle || "(no title)"}` : "";
            })
            .filter(Boolean)
            .join("\n");
        } else {
          parentLines = "‚Ä¢ None";
        }

        // ---- CHILDREN ----
        const children = tasks.filter(
          (x) =>
            Array.isArray(x.dependencies) && x.dependencies.includes(task._id)
        );

        let childLines = "";
        if (children.length > 0) {
          childLines = children
            .map((t) => `‚Ä¢ ${t.tasktitle || "(no title)"}`)
            .join("\n");
        } else {
          childLines = "‚Ä¢ None";
        }

        return (
          "\n\nDependencies:" +
          "\nParents:\n" +
          parentLines +
          "\nChildren:\n" +
          childLines
        );
      }
      document.addEventListener("keydown", async (e) => {
        // Must have selected tasks
        if (selectedTaskIds.length === 0) return;

        // Accept both Delete and Backspace (optional)
        if (e.key !== "Delete") return;

        // Prevent browser from navigating back
        e.preventDefault();

        const count = selectedTaskIds.length;

        // Confirmation
        if (!confirm(`Delete ${count} selected milestone(s)?`)) return;

        // Perform the delete
        for (const id of selectedTaskIds) {
          await deleteTask(id); // You already have this function
        }

        // Clear selection after deleting
        clearSelection();
      });
      document.addEventListener("click", (e) => {
        const taskDiv = e.target.closest(".task-block");
        if (!taskDiv) return;

        const tid = taskDiv.dataset.taskId;
        const task = window.currentRows.find((t) => t._id === tid);
        if (!task) return;

        // SHIFT + ALT = Only select CLOSED tasks
        if (e.shiftKey && e.altKey) {
          if ((task.status || "").toLowerCase() !== "closed") {
            return; // ignore open tasks
          }

          // Multi-select closed tasks only
          if (!selectedTaskIds.includes(tid)) {
            selectedTaskIds.push(tid);
            taskDiv.classList.add("task-selected");
          }

          return;
        }
      });
      document.addEventListener("keydown", async (e) => {
        // SHIFT + ALT + O
        if (e.key.toLowerCase() === "o" && e.shiftKey && e.altKey) {
          if (selectedTaskIds.length === 0) return;

          // Filter only CLOSED tasks
          const closedOnly = selectedTaskIds.filter((id) => {
            const t = window.currentRows.find((r) => r._id === id);
            return t && (t.status || "").toLowerCase() === "closed";
          });

          if (closedOnly.length === 0) {
            alert("No closed milestones selected to open.");
            return;
          }

          if (!confirm(`Open ${closedOnly.length} closed milestone(s)?`))
            return;

          for (const id of closedOnly) {
            await updateTask(id, {
              status: "open",
              // keep dates unchanged
            });
          }

          clearSelection();
        }
      });
    </script>
  </body>
</html>
