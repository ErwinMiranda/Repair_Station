<!doctype html>
<html lang="en">
<head>
  <script src="auth.js"></script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Real-time Excel → Firestore (Tasks)</title>
  <style>
    :root { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    body { max-width:1100px; margin:18px auto; padding:18px; }
    h1 { margin:0 0 8px 0; font-size:20px; }
    .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:12px 0; }
    button { padding:8px 12px; border-radius:6px; border:1px solid #bbb; background:#f5f5f5; cursor:pointer; }
    button.primary { background:#0b74de; color:white; border-color:#0a66c2; }
    button.danger { background:#ffe6e6; border-color:#ff8b8b; }
    input[type=file] { padding:6px; }
    .status { margin-left:6px; color:#333; font-size:13px; }
    #tasksTable { width:100%; border-collapse:collapse; margin-top:12px; max-height:520px; overflow:auto; display:block; }
    #tasksTable thead { background:#fafafa; position:sticky; top:0; z-index:2; }
    #tasksTable th, #tasksTable td { padding:6px 8px; border:1px solid #eee; text-align:left; font-size:13px; }
    #tasksTable tbody tr:nth-child(odd) { background:#fff; }
    #tasksTable tbody tr:nth-child(even) { background:#fbfbfb; }
    pre { max-height:300px; overflow:auto; background:#f7f7f7; padding:10px; border-radius:6px; }
    .small { font-size:13px; color:#666; }
  </style>
</head>
<body>
  <h1>Milestone Planning Database (Tasks)</h1>
  
  <div class="small">Uploads Excel rows to Firestore (collection: <code>tasks</code>) using <code>taskid</code> as document ID. Live updates via Firestore onSnapshot.</div>
  <button onclick="logout()">Logout</button>
  <div class="controls">
    <input id="file" type="file" accept=".xlsx,.xls,.csv" />
    <button id="uploadBtn" class="primary">Parse & Upload to Firestore</button>
    <button id="saveLocalBtn">Save Locally Only</button>
    <button id="exportBtn">Export Local JSON</button>
    <button id="clearRemoteBtn" class="danger">Clear Remote (delete all)</button>
    <label style="margin-left:8px"><input id="useRemote" type="checkbox" checked /> Use Firestore (remote)</label>
    <span class="status" id="status">Ready</span>
  </div>

  <div style="display:flex; gap:12px;">
    <div style="flex:1 1 60%;">
      <table id="tasksTable" aria-label="Tasks table">
        <thead>
          <tr id="headerRow">
            <!-- header populated dynamically -->
          </tr>
        </thead>
        <tbody id="tasksBody">
          <tr><td colspan="12" class="small">No tasks loaded yet.</td></tr>
        </tbody>
      </table>
    </div>
   <div style="flex:1 1 35%;">
      <h3 style="margin:0 0 6px 0">Preview (local cache)</h3>
      <pre id="jsonPreview">No local data</pre>
   
  </div>

  <!-- SheetJS for parsing -->
  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
  <script>
  const SESSION_KEY = "demo_session";
  const savedSession = JSON.parse(localStorage.getItem(SESSION_KEY) || sessionStorage.getItem(SESSION_KEY));

  if (!savedSession) {
    location.href = "index.html"; // not logged in
  } else {
    // Role-based access check
    const page = location.pathname.split("/").pop(); // current file name
    if (savedSession.page !== page) {
      location.href = "index.html"; // redirect if wrong user for this page
    }
  }
</script>

  <script> type="module">
    // ----- Firebase modular imports -----
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import {
      getFirestore, collection, doc, setDoc, writeBatch, onSnapshot, query, orderBy, getDocs, deleteDoc, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";

    // ----- Replace/confirm your firebaseConfig here -----
    const firebaseConfig = {
      apiKey: "AIzaSyBZ6wqCgHdV_gGG5jxEHEIo_bu0-gK0Bn8",
      authDomain: "webmp-b83f7.firebaseapp.com",
      projectId: "webmp-b83f7",
      storageBucket: "webmp-b83f7.appspot.com",
      messagingSenderId: "777263885684",
      appId: "1:777263885684:web:f1c0121ed62c606b7f5021"
    };
    // ----------------------------------------------------

    // Initialize Firebase
    let app, db;
    let firebaseReady = false;
    try {
      app = initializeApp(firebaseConfig);
      db = getFirestore(app);
      firebaseReady = true;
    } catch (e) {
      console.warn("Firebase init failed:", e);
      firebaseReady = false;
    }

    // DOM refs
    const fileInput = document.getElementById('file');
    const uploadBtn = document.getElementById('uploadBtn');
    const saveLocalBtn = document.getElementById('saveLocalBtn');
    const statusSpan = document.getElementById('status');
    const preview = document.getElementById('jsonPreview');
    const tasksBody = document.getElementById('tasksBody');
    const headerRow = document.getElementById('headerRow');
    const useRemote = document.getElementById('useRemote');
    const exportBtn = document.getElementById('exportBtn');
    const clearRemoteBtn = document.getElementById('clearRemoteBtn');

    const LOCAL_KEY = 'excel_tasks_local_v1';
    const TASKS_COLLECTION = 'tasks';
    const BATCH_LIMIT = 400; // stay under Firestore 500 limit, leave margin

    function setStatus(msg, isError=false){
      statusSpan.textContent = msg;
      statusSpan.style.color = isError ? 'crimson' : '#333';
    }

    // Convert SheetJS date or string to ISO date (yyyy-mm-dd) if possible; else return original string
    function normalizeDate(value){
      if(value == null) return null;
      // If it's a Date object
      if(Object.prototype.toString.call(value) === '[object Date]'){
        if(isNaN(value)) return null;
        const y = value.getFullYear();
        const m = String(value.getMonth()+1).padStart(2,'0');
        const d = String(value.getDate()).padStart(2,'0');
        return `${y}-${m}-${d}`;
      }
      // If it's a number (Excel serialized date may appear as number)
      if(typeof value === 'number'){
        // Excel dates can be parsed by SheetJS earlier; but fallback: use JS epoch baseline (not perfect)
        // We'll convert by treating value as days since 1899-12-31 which XLSX uses when dateNF present
        const excelEpoch = new Date(1899,11,30); // 1899-12-30 is the baseline sometimes used
        const dt = new Date(excelEpoch.getTime() + value * 24*60*60*1000);
        const y = dt.getFullYear();
        const m = String(dt.getMonth()+1).padStart(2,'0');
        const d = String(dt.getDate()).padStart(2,'0');
        return `${y}-${m}-${d}`;
      }
      // If it's a string like "7/19/2025" or "2025-07-19", try Date parse
      const maybe = new Date(value);
      if(!isNaN(maybe)) {
        const y = maybe.getFullYear();
        const m = String(maybe.getMonth()+1).padStart(2,'0');
        const d = String(maybe.getDate()).padStart(2,'0');
        return `${y}-${m}-${d}`;
      }
      return String(value);
    }

    // Parse Excel into array of objects
    function parseFileToRows(file){
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = e.target.result;
            const wb = XLSX.read(data, { type: 'binary' });
            // We'll take the first sheet by default
            const sheetName = wb.SheetNames[0];
            const sheet = wb.Sheets[sheetName];
            const rows = XLSX.utils.sheet_to_json(sheet, { defval: null });
            // Normalize column names to lowercase trimmed keys (optional)
            const normalized = rows.map(r => {
              const out = {};
              for(const key in r){
                if(!Object.prototype.hasOwnProperty.call(r,key)) continue;
                const k = key.toString().trim();
                // keep original case for header display, but use canonical field names:
                // We'll map any header to expected fields if possible (case-insensitive)
                out[k] = r[key];
              }
              return out;
            });
            resolve(normalized);
          } catch (err) { reject(err); }
        };
        reader.onerror = reject;
        reader.readAsBinaryString(file);
      });
    }

    // Map row object to canonical fields expected by UI/Firestore
    function mapRow(raw){
      // Attempt to find fields by case-insensitive header matching
      const mapKey = (names) => {
        // names: array of possible header names in priority order
        const keys = Object.keys(raw);
        for(const n of names){
          const found = keys.find(k => k.trim().toLowerCase() === n.toLowerCase());
          if(found) return found;
        }
        return null;
      };
      const out = {};
      out.taskid = raw[mapKey(['taskid','task id','id'])] ?? null;
      out.skill = raw[mapKey(['skill'])] ?? raw['skill'] ?? null;
      out.sdate = normalizeDate(raw[mapKey(['sdate','start','start date'])] ?? null);
      out.edate = normalizeDate(raw[mapKey(['edate','end','end date'])] ?? null);
      out.rev_sdate = normalizeDate(raw[mapKey(['rev_sdate','rev sdate','rev start'])] ?? null);
      out.rev_edate = normalizeDate(raw[mapKey(['rev_edate','rev edate','rev end'])] ?? null);
      out.tasktitle = raw[mapKey(['tasktitle','task title','title'])] ?? null;
      out.remarks = raw[mapKey(['remarks'])] ?? null;
      out.status = raw[mapKey(['status'])] ?? null;
      out.acreg = raw[mapKey(['acreg','aircraft','ac reg'])] ?? null;
      out.workorder = raw[mapKey(['workorder','work order','wo'])] ?? null;
      out.bay = raw[mapKey(['bay'])] ?? null;

      // Add raw extras copy for debugging
      out._raw = raw;
      return out;
    }

    // Save to localStorage
    function saveLocal(data){
      try {
        localStorage.setItem(LOCAL_KEY, JSON.stringify({ savedAt: Date.now(), rows: data }));
        setStatus('Saved local snapshot');
      } catch(e){
        console.warn('local save failed', e);
        setStatus('Local save failed', true);
      }
    }

    // Load local
    function loadLocal(){
      try {
        const raw = localStorage.getItem(LOCAL_KEY);
        if(!raw) return null;
        const parsed = JSON.parse(raw);
        return parsed.rows || null;
      } catch(e) { return null; }
    }
        const HEADER_LABELS = {
  taskid: "Task ID",
  skill: "Skill",
  sdate: "Start Date",
  edate: "End Date",
  rev_sdate: "Revised Start",
  rev_edate: "Revised End",
  tasktitle: "Task Title",
  remarks: "Remarks",
  status: "Status",
  acreg: "AC Reg",
  workorder: "Work Order",
  bay: "Bay"
};

    // Render table from rows array (array of mapped rows)
function renderTable(rows) {
  const headers = Object.keys(HEADER_LABELS);

  // Sort by sdate then taskid
  rows = [...rows].sort((a, b) => {
    const dateA = new Date(a.sdate || "2100-01-01");
    const dateB = new Date(b.sdate || "2100-01-01");
    if (dateA - dateB !== 0) return dateA - dateB;
    return String(a.taskid).localeCompare(String(b.taskid));
  });

  // Render header
  headerRow.innerHTML = '';
  headers.forEach(h => {
    const th = document.createElement('th');
    th.textContent = HEADER_LABELS[h] || h;
    headerRow.appendChild(th);
  });

  // Render body
  tasksBody.innerHTML = '';
  if (!rows || rows.length === 0) {
    const tr = document.createElement('tr');
    const td = document.createElement('td');
    td.colSpan = headers.length;
    td.className = 'small';
    td.textContent = 'No tasks found.';
    tr.appendChild(td);
    tasksBody.appendChild(tr);
    return;
  }

  rows.forEach(r => {
    const tr = document.createElement('tr');
    headers.forEach(h => {
      const td = document.createElement('td');
      let v = r[h] ?? '';
      td.textContent = v;

      // Highlight missing Bay
      if (h === 'bay' && (!v || String(v).trim() === '')) {
        td.style.backgroundColor = '#ffe6e6';
        td.style.color = '#a00';
        td.textContent = '(missing)';
      }

      tr.appendChild(td);
    });
    tasksBody.appendChild(tr);
  });
}


    // Batch upload mapped rows to Firestore using taskid as doc ID
    async function uploadRowsToFirestore(mappedRows){
      if(!firebaseReady) throw new Error('Firebase not initialized');
      if(!Array.isArray(mappedRows) || mappedRows.length === 0) return;

      // Ensure each row has taskid
      const missing = mappedRows.filter(r => !r.taskid || String(r.taskid).trim() === '');
      if(missing.length){
        throw new Error('Some rows missing taskid. Ensure the sheet has a taskid column and each row has a value.');
      }

      // Chunk into BATCH_LIMIT per batch
      const chunks = [];
      for(let i=0;i<mappedRows.length;i+=BATCH_LIMIT){
        chunks.push(mappedRows.slice(i, i+BATCH_LIMIT));
      }

      setStatus(`Uploading ${mappedRows.length} rows in ${chunks.length} batch(es)...`);
      for(const [ci, chunk] of chunks.entries()){
        const batch = writeBatch(db);
        for(const row of chunk){
          const id = String(row.taskid).trim();
          const docRef = doc(db, TASKS_COLLECTION, id);
          // Prepare payload (remove _raw or keep if useful)
          const payload = {
            taskid: row.taskid ?? null,
            skill: row.skill ?? null,
            sdate: row.sdate ?? null,
            edate: row.edate ?? null,
            rev_sdate: row.rev_sdate ?? null,
            rev_edate: row.rev_edate ?? null,
            tasktitle: row.tasktitle ?? null,
            remarks: row.remarks ?? null,
            status: row.status ?? null,
            acreg: row.acreg ?? null,
            workorder: row.workorder ?? null,
            bay: row.bay ?? null,

            updatedAt: serverTimestamp()
          };
          // Overwrite document with set (via batch.set)
          batch.set(docRef, payload);
        }
        await batch.commit();
        setStatus(`Committed batch ${ci+1}/${chunks.length}`);
      }
      setStatus('All batches uploaded');
    }

    // Delete all docs in tasks collection (CAREFUL)
    async function clearRemoteCollection(){
      if(!firebaseReady) throw new Error('Firebase not initialized');
      setStatus('Clearing remote collection (fetching docs first)...');
      // Fetch all doc IDs (be aware of large collections)
      const q = query(collection(db, TASKS_COLLECTION));
      const snap = await getDocs(q);
      if(snap.empty){ setStatus('Remote collection empty'); return; }
      const docs = snap.docs;
      const chunks = [];
      for(let i=0;i<docs.length;i+=BATCH_LIMIT){
        chunks.push(docs.slice(i, i+BATCH_LIMIT));
      }
      for(const [ci, chunk] of chunks.entries()){
        const batch = writeBatch(db);
        for(const d of chunk){
          batch.delete(d.ref);
        }
        await batch.commit();
        setStatus(`Deleted chunk ${ci+1}/${chunks.length}`);
      }
      setStatus('Remote collection cleared');
    }

    // Listen to Firestore collection in real-time and render table
    function attachRealtimeListener(){
      if(!firebaseReady) {
        setStatus('Firestore not available — running local only');
        return;
      }
      const q = query(collection(db, TASKS_COLLECTION), orderBy('sdate'));
      // onSnapshot will call immediately with current data then update on changes
      onSnapshot(q, snapshot => {
        const rows = [];
        snapshot.forEach(docSnap => {
          const d = docSnap.data();
          rows.push({
            taskid: d.taskid ?? docSnap.id,
            skill: d.skill ?? '',
            sdate: d.sdate ?? '',
            edate: d.edate ?? '',
            rev_sdate: d.rev_sdate ?? '',
            rev_edate: d.rev_edate ?? '',
            tasktitle: d.tasktitle ?? '',
            remarks: d.remarks ?? '',
            status: d.status ?? '',
            acreg: d.acreg ?? '',
           workorder: d.workorder ?? '',
            bay: d.bay ?? ''

            
          });
        });
        renderTable(rows);
        // Keep local cache in sync with remote (optionally)
        try { localStorage.setItem(LOCAL_KEY, JSON.stringify({ savedAt: Date.now(), rows })); } catch {}
        setStatus(`Realtime: ${rows.length} tasks`);
      }, err => {
        console.error('onSnapshot error', err);
        setStatus('Realtime listener error (see console)', true);
      });
    }

    // Wire buttons
    uploadBtn.addEventListener('click', async () => {
      const file = fileInput.files?.[0];
      if(!file) return setStatus('Select a file first', true);
      setStatus('Parsing file...');
      try {
        const rows = await parseFileToRows(file);
        // Map rows to canonical structure
        const mapped = rows.map(r => mapRow(r));
        // Show preview and save local
        preview.textContent = JSON.stringify(mapped, null, 2);
        saveLocal(mapped);
        if(useRemote.checked){
          setStatus('Uploading to Firestore...');
          await uploadRowsToFirestore(mapped);
        } else {
          setStatus('Local-only saved (remote checkbox unchecked)');
        }
      } catch (err) {
        console.error(err);
        setStatus('Error: ' + (err.message || err), true);
      }
    });

    saveLocalBtn.addEventListener('click', async () => {
      const file = fileInput.files?.[0];
      if(!file) return setStatus('Select a file first', true);
      setStatus('Parsing file for local save...');
      try {
        const rows = await parseFileToRows(file);
        const mapped = rows.map(r => mapRow(r));
        preview.textContent = JSON.stringify(mapped, null, 2);
        saveLocal(mapped);
      } catch (err) {
        console.error(err);
        setStatus('Error: ' + (err.message || err), true);
      }
    });

    exportBtn.addEventListener('click', () => {
      const local = loadLocal();
      if(!local) return setStatus('No local data to export', true);
      const blob = new Blob([JSON.stringify(local, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'tasks_export.json';
      a.click();
      URL.revokeObjectURL(url);
      setStatus('Export started');
    });

    clearRemoteBtn.addEventListener('click', async () => {
      if(!useRemote.checked) return setStatus('Remote disabled', true);
      if(!confirm('This will DELETE ALL documents in the remote "tasks" collection. Are you sure?')) return;
      try {
        setStatus('Deleting remote documents...');
        await clearRemoteCollection();
      } catch(err) {
        console.error(err);
        setStatus('Error clearing remote collection: ' + (err.message||err), true);
      }
    });

    // On load: populate preview from local and attach realtime listener
    (function init(){
      const local = loadLocal();
      if(local){
        preview.textContent = JSON.stringify(local, null, 2);
        // Render local preview in table while waiting for realtime data
        try {
          const previewRows = local.map(r => ({
            taskid: r.taskid ?? '',
            skill: r.skill ?? '',
            sdate: r.sdate ?? '',
            edate: r.edate ?? '',
            rev_sdate: r.rev_sdate ?? '',
            rev_edate: r.rev_edate ?? '',
            tasktitle: r.tasktitle ?? '',
            remarks: r.remarks ?? '',
            status: r.status ?? '',
            acreg: r.acreg ?? '',
            workorder: r.workorder ?? '',
            bay: r.bay ?? ''
          }));
          renderTable(previewRows);
          setStatus('Loaded local snapshot');
        } catch(e){}
      } else {
        setStatus('No local snapshot found');
      }
      if(firebaseReady) {
        attachRealtimeListener();
      } else {
        setStatus('Firebase not initialized — running local-only', true);
      }
    })();
    
  </script>
</body>
</html>

